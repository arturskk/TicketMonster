<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <bookinfo>
    <title>Snowdrop Ticket Monster Example Application</title>

    <subtitle>Integrating Spring with the JBoss Enterprise Application
    Platforms</subtitle>

    <productname>JBoss Web Framework Kit</productname>

    <productnumber>2.0</productnumber>

    <edition>1.0</edition>

    <pubsnumber>0</pubsnumber>

    <abstract>
      <para>This book provides a walkthrough for the Snowdrop Ticket Monster
      example application. It illustrates several use cases of the JBoss
      Enterprise Application Platform with the Spring Framework.</para>
    </abstract>

    <corpauthor>JBoss by Red Hat</corpauthor>

    <authorgroup>
      <author>
        <firstname>Ryan</firstname>

        <surname>Bradley</surname>

        <affiliation>
          <orgname>JBoss by Red Hat</orgname>
        </affiliation>

        <email>rbradley@redhat.com</email>
      </author>

      <author>
        <firstname>Marius</firstname>

        <surname>Bogoevici</surname>

        <affiliation>
          <orgname>JBoss by Red Hat</orgname>
        </affiliation>

        <email>mariusb@redhat.com</email>
      </author>
    </authorgroup>

    <pubdate>October 7, 2011</pubdate>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <section>
      <title>Feedback</title>

      <para>If you find a typographical error in this manual, or if you have
      thought of a way to make this manual better, we would love to hear from
      you! Please submit a report in JIRA: <ulink
      url="http://jira.jboss.org/">http://jira.jboss.org/</ulink> against the
      product <application>Snowdrop</application> and component
      <emphasis>Examples</emphasis>.</para>

      <para>When submitting a bug report, be sure to mention the manual's
      identifier: Snowdrop <citetitle>Ticket Monster
      Example</citetitle>.</para>

      <para>If you have a suggestion for improving the documentation, try to
      be as specific as possible when describing it. If you have found an
      error, please include the section number and some of the surrounding
      text so we can find it easily.</para>
    </section>
  </preface>

  <chapter>
    <title>Introduction</title>

    <para>The Ticket Monster application provides a real world-inspired
    example of integrating Spring with the JBoss Entprise Platforms. It is a
    web application, which illustrates several use cases through various
    combinations of components and technologies. It also illustrates how to
    use the Snowdrop libraries to provide JBoss-specific features, such as
    creating a standalone deployment of an
    <classname>ApplicationContext</classname> and using many Spring-provided
    features like security and caching.</para>

    <para>This book aims to illustrate the mechanics of using Spring with
    different Java EE 6 components in the specific context of the JBoss
    Enterprise Platforms, and to recommend methods of achieving certain
    integration goals.</para>

    <para>The Ticket Monster example is not intended as a guide to creating a
    domain model. Detailing the various layers of application and UI design is
    outside the scope of this document. As such, the example application has
    been designed to illustrate integration use cases, rather than to
    demonstrate a domain model that strictly follows principles of
    object-oriented and domain-driven design.</para>

    <section>
      <title>Prerequisites</title>

      <para>Deployment of the Ticket Monster application requires the
      following:</para>

      <itemizedlist>
        <listitem>
          <para>Java 6 JDK</para>
        </listitem>

        <listitem>
          <para>JBoss Application Server 7.0.0.Final or later</para>
        </listitem>

        <listitem>
          <para>Maven 2.0.9 or later, with appropriate repositories</para>
        </listitem>
      </itemizedlist>

      <simplesect>
        <title>Setting Up Maven Repositories</title>

        <para>The Maven project setup does not make any assumptions where the
        artifacts used in the project are coming from (which repository), as
        users may have different settings for their Maven repositories (direct
        access to community repositories, proxies, enterprise repository with
        approved artifacts). Therefore, the setup of the repositories is left
        to the user of the application.</para>

        <para>In the most simple case, this example can be built out of the
        box if the settings.xml file for the local Maven installation enables
        the repositories from Maven Central and JBoss Releases. Instructions
        for setting up the latter can be found at:
        http://community.jboss.org/wiki/MavenGettingStarted-Users.</para>

        <para>The pom.xml can be modified to include references to other
        repositories, or equivalent artifact versions (if the build
        environment uses an enterprise-wide repository in which the artifacts
        have different version numbers).</para>
      </simplesect>
    </section>

    <section>
      <title>How to Build and Run Ticket Monster</title>

      <para>This document will provide a detailed account of the application
      and its use cases. However, often, it is easier to just run the
      application to answer your questions.</para>

      <itemizedlist>
        <listitem>
          <para>Building the application</para>
        </listitem>

        <listitem>
          <para>Preparing JBoss</para>
        </listitem>

        <listitem>
          <para>Deploying the application</para>
        </listitem>

        <listitem>
          <para>Starting the application server</para>
        </listitem>
      </itemizedlist>

      <para>Below, you will find instructions on how to perform each of these
      steps.</para>

      <section>
        <title>Building the Application</title>

        <para>In this step, we build the application. Since Ticket Monster
        uses Maven, so it can be built from the command line by simple
        running:</para>

        <informalexample>
          <programlisting>mvn clean package</programlisting>

          <para>This produces a WAR file, named TicketMonster.war, under
          TicketMonster/target. The application can then be deployed by moving
          this .war file to ${JBOSS_AS_7_HOME}/standalone/deployments and then
          executing the standalone.sh script, located in
          ${JBOSS_AS_7_HOME}/bin directory. The database will be initialized
          during this process by the SQL script, import.sql, included in the
          src/main/resources directory of the Ticket Monster project. Ticket
          Monster uses Spring 3.1.0.M2 and Spring Security 3.1.0.RC2.</para>
        </informalexample>
      </section>

      <section>
        <title>Preparing JBoss</title>

        <para>In addition to building the application, the JBoss Application
        Server must also be properly configured before deploying the
        application. Specifically, this involves creating a datasource
        definition within the configuration of the JBoss Application Server.
        In this guidebook, we describe two different alternative data source
        implementations - an in-memory database and a persistent database. To
        begin, we will show how to configure a persistent database, as it is
        aligned more closely with the Ticket Monster use cases. To configure a
        data source, we must edit the standalone.xml file, located in
        ${JBOSS_AS_7_HOME}/standalone/configuration.</para>

        <section>
          <title>Database Persistence</title>

          <para>One major issue with an in-memory database implementation is
          that the Ticket Monster application has the functionality to support
          most of its use cases, such as reserving tickets for multiple shows
          and finalizing those reservations. However, one disadvantage of the
          current application structure is that, whenever the application
          server is shut down, this information is lost, as Ticket Monster
          uses an in-memory database. A more realistic implementation of the
          Ticket Monster use cases would use a separate, persistent database,
          which stores information, such as previously made allocations, even
          when the application server is not running. The changes required to
          implement database persistence within Ticket Monster are very
          simple. First, we must modify our data source definition within the
          &lt;datasources&gt; element of standalone.xml, it should now
          be:<informalexample>
              <programlisting>&lt;datasource jndi-name="java:jboss/datasources/TicketMonsterDS" pool-name="TicketMonsterDS" enabled="true" jta="true" use-java-context="true" use-ccm="true"&gt;
    &lt;connection-url&gt;
        jdbc:hsqldb:hsql://localhost/ticketmonsterds
    &lt;/connection-url&gt;
    &lt;driver&gt;
        hsqldb
    &lt;/driver&gt;
    &lt;pool&gt;
        &lt;prefill&gt;
            false
        &lt;/prefill&gt;
        &lt;use-strict-min&gt;
            false
        &lt;/use-strict-min&gt;
        &lt;flush-strategy&gt;
            FailingConnectionOnly
        &lt;/flush-strategy&gt;
    &lt;/pool&gt;
    &lt;security&gt;
        &lt;user-name&gt;
            sa
        &lt;/user-name&gt;
        &lt;password&gt;
                            
        &lt;/password&gt;
    &lt;/security&gt;
    &lt;validation&gt;
        &lt;validate-on-match&gt;
            false
        &lt;/validate-on-match&gt;
        &lt;background-validation&gt;
            false
        &lt;/background-validation&gt;
        &lt;use-fast-fail&gt;
            false
        &lt;/use-fast-fail&gt;
    &lt;/validation&gt;
&lt;/datasource&gt;</programlisting>
            </informalexample></para>

          <para>This data source definition creates a data source, called
          TicketMonsterDS, that is independent of the application server and
          can be referenced than the application, as opposed to one that is
          created whenever the application server is started.</para>

          <para>To create and initialize our database, we must add a file,
          create-db.sql, which creates tables for each of Ticket Monster's
          entities, first dropping those tables if they already exist in the
          database. Then we add two scripts, server.sh and init-db.sh, the
          former to start the database and the latter to initialize it. Thus,
          we now execute './server.sh' to start the database, and
          './init-db.sh', which executes the SQL files create-db.sql and then
          import.sql, to initialize it. Once these steps have been performed,
          we can deploy the application with database persistence, i.e. even
          if we restart the application server, allocations will be maintained
          unless we execute the init-db.sh script again. The aforementioned
          SQL files, including import.sql (moved from src/main/resources), can
          be found in the 'db' sub-directory of the Ticket Monster
          project.</para>

          <para>It should be also mentioned that database persistence places
          some additional requirements on the business logic of the
          application. Specifically, Ticket Monster must bootstrap the cache.
          In other words, whenever a seat block is requested for a given show
          and row pair, the application must first retrieve all allocations
          for that row and show and place them in the cache, to avoid
          overlapping reservations. This is accomplished via the
          populateCache() method of the AllocationDao interface.</para>
        </section>

        <section>
          <title>In-Memory Database</title>

          <para>As well, we include instructions on how to set up an in-memory
          database. First, we must edit our data source definition for
          'TicketMonsterDS' so that it now reads:</para>

          <para><informalexample>
              <para><programlisting>&lt;datasource jndi-name="java:jboss/datasources/TicketMonsterDS" pool-name="TicketMonsterDS"
   enabled="true" jta="true" use-java-context="true" use-ccm="true"&gt;
   &lt;connection-url&gt;
      jdbc:h2:mem:test;DB_CLOSE_DELAY=-1
   &lt;/connection-url&gt;
   &lt;driver&gt;
      h2
   &lt;/driver&gt;
   &lt;pool&gt;
      &lt;prefill&gt;
          false
      &lt;/prefill&gt;
      &lt;use-strict-min&gt;
          false
      &lt;/use-strict-min&gt;
      &lt;flush-strategy&gt;
          FailingConnectionOnly
      &lt;/flush-strategy&gt;
   &lt;/pool&gt;
   &lt;security&gt;
      &lt;user-name&gt;
          sa
      &lt;/user-name&gt;
      &lt;password&gt;
          sa
      &lt;/password&gt;
   &lt;/security&gt;
   &lt;validation&gt;
      &lt;validate-on-match&gt;
          false
      &lt;/validate-on-match&gt;
      &lt;background-validation&gt;
          false
      &lt;/background-validation&gt;
      &lt;useFastFail&gt;
          false
      &lt;/useFastFail&gt;
   &lt;/validation&gt;
&lt;/datasource&gt;</programlisting>This definition is necessary for the
              application to be create an in-memory database for the
              application, which can be retrieved via a JNDI look-up.</para>

              <para>Next, we must modify our persistence.xml file, located in
              src/main/resources/META-INF, adding one of the properties of our
              persistence unit, ticketmonsterPU. Specifically, we include the
              property '&lt;property name="hibernate.hbm2ddl.auto"
              value="create-drop"/&gt;'. This property causes the application
              server to drop the database schema whenever the SessionFactory
              is closed explicitly. Previously, this contradicted our
              persistent database implementation, as we wanted consistent data
              from session to session. However, with an in-memory database,
              the database is destroyed and re-created whenever the
              application server is restarted, so this property is
              desired.</para>
            </informalexample></para>
        </section>
      </section>

      <section>
        <title>Deploying the Application</title>

        <para>Copy the WAR file produced by the build to deploy folder of the
        JBoss Application Server.</para>

        <para>The WAR file is located in TicketMonster/target, and should be
        copied to ${JBOSS_AS_7_HOME}/standalone/deployments.</para>
      </section>

      <section>
        <title>Authenticated Access</title>

        <para>Accessing all views of the Ticket Monster web application
        requires the login information for users with the proper
        authorization. Specifically, the views related to booking tickets
        cannot be accessed by anyone but a User in the Ticket Monster
        database. Below are the three 'username, "password" ' pairs that come
        provided with the Ticket Monster application:<itemizedlist>
            <listitem>
              <para>rbradley, "ticketmonster"</para>
            </listitem>

            <listitem>
              <para>mbg, "marius"</para>
            </listitem>

            <listitem>
              <para>sbryzak, "original"</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>

    <section>
      <title>Ticket Monster and JBoss Developer's Studio</title>

      <para>The easiest way to gain a deeper understanding of the Ticket
      Monster web application is to examine the source code directly. This
      guide will instruct you how to import the application into JBoss
      Developer's Studio (JBDS).</para>

      <para>Ticket Monster is a Maven-based application; thus, to navigate its
      structure in JBoss Developer's Studio, you must create an Eclipse
      project for it. This can be done using the Maven Eclipse
      plugin:<informalexample>
          <programlisting>mvn eclipse:eclipse -Dwtpversion=2.0</programlisting>

          <para>Alternatively, the m2e Maven Integration for Eclipse plugin
          can be used to import the project into JBoss Developer's
          Studio.</para>
        </informalexample></para>

      <simplesect>
        <title>Importing Ticket Monster into JBDS</title>

        <para>Ticket Monster is a Maven-based project, so you can import it
        into JBDS if you have the m2eclipse Maven integration plugin
        installed, including the m2eclipse WTP extension. Installation can be
        found at http://download.eclipse.org/technology/m2e/releases/.</para>

        <para>For importing the project, go to
        'Import...'-&gt;'Maven'-&gt;'Existing Maven Projects' and select the
        top directory of the Ticket Monster example. You will be shown the
        project's pom.xml file.</para>
      </simplesect>
    </section>
  </chapter>

  <chapter>
    <title>Understanding the Application Structure</title>

    <para>This chapter will describe the business use cases covered by the
    Ticket Monster application.</para>

    <section>
      <title>Application Structure and Use Cases</title>

      <para>The Ticket Monster application is an example of an online ticket
      reseller, such as Ticketmaster. Users of Ticket Monster should be able
      to retrieve information about events from the website:<itemizedlist>
          <listitem>
            <para>View all events in the Ticket Monster database</para>
          </listitem>

          <listitem>
            <para>Query the database of events based on start date, end date,
            event category, whether it is major or not, etc.</para>
          </listitem>

          <listitem>
            <para>Retrieve event specific information such as event
            description, host venues, venue information, seating sections and
            prices, and show times</para>
          </listitem>

          <listitem>
            <para>View all venues in the Ticket Monster database</para>
          </listitem>

          <listitem>
            <para>Display all events being held at a specific venue, and
            navigate to individual event pages</para>
          </listitem>
        </itemizedlist></para>

      <para>As well, users need to reserve and purchase tickets for shows,
      i.e. occurrences of an event at a specific venue. To accomplish this,
      the application has the following requirements:<itemizedlist>
          <listitem>
            <para>Check a user's security credentials using Spring
            Security</para>
          </listitem>

          <listitem>
            <para>Reserve seats from specific sections to the current user for
            specific shows</para>
          </listitem>

          <listitem>
            <para>Manage a cache of currently reserved or purchased seats for
            shows in the Ticket Monster database</para>
          </listitem>

          <listitem>
            <para>Maintain a session-scoped object of the current user's
            reservations, allocations (i.e. purchased seats), and price of
            tickets in the user's shopping cart</para>
          </listitem>

          <listitem>
            <para>Persist purchased reservations to the database when a user
            finishes allocating seats or 'checks out'</para>
          </listitem>

          <listitem>
            <para>Display a list of all purchased seat blocks and the total
            price on the check out page</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Managing Dependencies</title>

      <para>This section will discuss the various dependencies brought into
      the application by Maven, as specified in Ticket Monster's pom.xml file,
      and why they are necessary to the project. As well, we will discuss a
      few other changes to the project structure that are necessary for
      deployment, such as the inclusion of a
      /WEB-INF/jboss-deployment-structure.xml file and its contents.</para>

      <para>Dependencies are included as one of three scopes: provided,
      compile, and test. 'Provided' dependencies are those which are included
      with the application before it is compile, such as dependencies packaged
      with the application server. 'Compile' dependencies are downloaded and
      added to the classpath when the application is compiled. Finally, 'test'
      dependencies are only included in the classpath when the application is
      running tests. Below is a list of dependencies (listed by group ID and
      artifact ID), their versions, and their importance to the Ticket Monster
      web application, i.e. why they were included with a certain scope:<table>
          <title>Overview of Ticket Monster Dependencies</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry align="center">Dependency (groupID:artifactID -
                version)</entry>

                <entry align="center">Purpose</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry align="left">junit:junit - 4.7</entry>

                <entry>The JUnit library is included for unit testing
                purposes. This library allows us to annotate methods as @Test,
                and to use the Assert class within the JUnit tests
                themselves.</entry>
              </row>

              <row>
                <entry>cglib:cglib-nodep - 2.2</entry>

                <entry>The cglib library is included with scope compile to
                extend Java classes or implement Java interfaces at run-time.
                This specific jar, cglib-nodep, is the version packaged with
                no dependencies.</entry>
              </row>

              <row>
                <entry>commons-dbcp:commons-dbcp - 1.2.2</entry>

                <entry>The commons-dbcp is included in Ticket Monster's
                pom.xml for testing purposes. To reduce wasted time opening
                connections for each user, we use the commons-dbcp library to
                maintain a pool of open database connections.</entry>
              </row>

              <row>
                <entry>commons-logging:commons-logging - 1.1.1</entry>

                <entry>The commons-logging library is included with scope
                provided for Ticket Monster's logging functionality. This
                dependency provides the Log and LogFactory classes used by
                Ticket Monster's advising (logging) classes within the
                'advice' package. The commons-logging library is provided
                directly as a dependency via the
                jboss-deployment-structure.xml file.</entry>
              </row>

              <row>
                <entry>commons-pool:commons-pool - 1.3</entry>

                <entry>The commons-pool library is included for testing of the
                Ticket Monster application. This package provides the
                underlying pool objects that are utilized by the Apache
                Commons Database Connectivity Pool (commons-dbcp).</entry>
              </row>

              <row>
                <entry>hsqldb:hsqldb - 1.8.0.10</entry>

                <entry>The HSQLDB library is provided in the scope test as it
                is used for the JDBC embedded database, which is necessary for
                JUnit testing of the repositories and service layer.</entry>
              </row>

              <row>
                <entry>org.aspectj:aspectjweaver - 1.6.11</entry>

                <entry>The aspectjweaver JAR is a dependency of Spring AOP,
                hence it is scoped compile. This library provides AspectJ
                Load-Time Weaving support, to integrate advice into the Ticket
                Monster run-time.</entry>
              </row>

              <row>
                <entry>org.aspectj:aspectjrt - 1.6.11</entry>

                <entry>The aspectjrt JAR is a dependency of Spring AOP, thus
                requiring its scope to be compile as well. The main importance
                of the aspectjrt library to Ticket Monster is that it provides
                all AspectJ-related annotations as well as definitions of the
                JoinPoint class.</entry>
              </row>

              <row>
                <entry>org.hibernate:hibernate-core - 3.3.0.GA</entry>

                <entry>The hibernate-core library, provided for Ticket Monster
                by the Java Persistence API, is necessary for persistence
                implementation, using the Object/Relational Mapping
                (ORM).</entry>
              </row>

              <row>
                <entry>org.hibernate:hibernate-entitymanager -
                3.4.0.GA</entry>

                <entry>The hibernate-entity-manager JAR, provided by the Java
                Persistence API, gives Ticket Monster a means of managing
                entities. This library includes implementations of the
                EntityManager and EntityManagerFactory interfaces, providing
                the application with an EntityManager object.</entry>
              </row>

              <row>
                <entry>org.jboss.spec.javax.servlet:jboss-servlet-api_3.0_spec
                - 1.0.0.FINAL</entry>

                <entry>The jboss-servlet-api package is provided by the JBoss
                Application Server. It includes classes, such as the
                HttpServletRequest and HttpServletResponse, which allow us to
                use Java to communicate with the servlet.</entry>
              </row>

              <row>
                <entry>org.slf4j:slf4j-simple - 1.4.2</entry>

                <entry>The slf4j-simple library is used for the testing of the
                Ticket Monster application. This library provides logging
                support for testing.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-aop - 3.1.0.RC1</entry>

                <entry>The Spring AOP library is included with scope compile
                for the the use of the &lt;aop&gt; namespace in the XML
                context files. Specifically, it is used for the
                &lt;aop:aspectj-autoproxy&gt; element, indicating the use of
                Spring AOP for advice on cross-cutting concerns.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-asm - 3.1.0.RC1</entry>

                <entry>The Spring ASM library, added at compile time, is an
                assembler library which is used analyze, modify, and
                manipulate Java code into binary code at runtime.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-beans - 3.1.0.RC1</entry>

                <entry>This dependency must be included with scope compile so
                that we can define Spring beans. For example, we need to
                declare Spring beans for the repository implementations, in
                order to inject them into the web controllers.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-context - 3.1.0.RC1</entry>

                <entry>The spring-context JAR is included as a dependency with
                scope compile so that we can use annotations such as
                @Component to indicate beans without explicitly declaring them
                in a *context.xml file. Beans for these classes will then be
                created if we target their package with a
                &lt;context:component-scan&gt;.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-context-support -
                3.1.0.RC1</entry>

                <entry>The spring-context-support JAR is necessary as its
                classes support the functionality of the Spring context
                namespace.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-core - 3.1.0.RC1</entry>

                <entry>This library contains, as its name suggests, Spring's
                core utilities which are used by many other Spring libraries.
                Thus, spring-core is itself a dependency for many of Ticket
                Monster's dependencies.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-expression -
                3.1.0.RC1</entry>

                <entry>The spring-expression JAR is necessary for the use of
                the Spring Expression Language (SpEL), which is used in the
                Ticket Monster example for XML-based bean definitions.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-jdbc - 3.1.0.RC1</entry>

                <entry>Spring's JDBC support, packaged in the spring-jdbc
                library, is used in Ticket Monster for two purposes. For one,
                it can be used for database setup and access if we are not
                using a persistent database. As well, it is used to configure
                an embedded database for testing of Ticket Monster.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-orm - 3.1.0.RC1</entry>

                <entry>The spring-orm library allows us to integrate Spring
                with support packages for Object Relational Mappers (ORM),
                such as the Java Persistence API and Hibernate.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-test - 3.1.0.RC1</entry>

                <entry>The spring-test library provides Spring's test context
                framework. For example, it allows us to use the
                @ContextConfiguration annotation, which can be used to specify
                the context files for a JUnit test. With this annotation, we
                can then create our own separate test context, allowing us to
                test the application more rigorously.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-tx - 3.1.0.RC1</entry>

                <entry>The spring-tx JAR is included as scope compile for the
                use of the &lt;tx&gt; namespace, e.g the
                &lt;tx:annotation-driven/&gt; element, which enables the use
                of Spring annotations like @Transactional.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-web - 3.10.RC1</entry>

                <entry>The spring-web JAR is included as scope compile for the
                use of Spring's web annotations. For example, this dependency
                is required for the use of annotations like @RequestMapping,
                which determines the URL mapping of a controller, or a method
                within that controller.</entry>
              </row>

              <row>
                <entry>org.springframework:spring-webmvc - 3.1.0.RC1</entry>

                <entry>This library is included with scope compile for the use
                of the &lt;mvc&gt; namespace in the
                ticketmonster-mvc-context.xml file. For example, the
                &lt;mvc:annotation-driven/&gt;, indicating that any Spring MVC
                controller classes will be annotated as @Controller.</entry>
              </row>

              <row>
                <entry>org.springframework.security:spring-security-core -
                3.1.0.RC2</entry>

                <entry>This JAR provides the core utilities for used by Spring
                Security's peripheral libraries.</entry>
              </row>

              <row>
                <entry>org.springframework.security:spring-security-config -
                3.1.0.RC2</entry>

                <entry>The spring-security-config library is added as scope
                compile so that the security namespace can be used in the
                application context; allowing us to properly configure our
                desired settings for Spring Security.</entry>
              </row>

              <row>
                <entry>org.springframework.security:spring-security-acl -
                3.1.0.RC2</entry>

                <entry>The spring-security-acl dependency, scoped compile, is
                necessary for domain object security. Spring Security creates
                an access control list (ACL) for each domain object in the
                application, which records what other objects can and cannot
                do with that object.</entry>
              </row>

              <row>
                <entry>org.springframework.security:spring-security-web -
                3.1.0.RC2</entry>

                <entry>The spring-security-web library, brought into Ticket
                Monster at compile time, contains filters and related
                web-infrastructure classes. For example, spring-security-web
                is required as a dependency if we are going to use Spring
                Security's web authentication services or URL-based access
                control (i.e. different user permissions for different
                URLs).</entry>
              </row>

              <row>
                <entry>org.springframework.security:spring-security-taglibs -
                3.1.0.RC2</entry>

                <entry>The spring-security-taglibs library, included with
                scope compile, is included so that security constraints can be
                applied in JSPs. For example, this allows us to use the
                &lt;sec&gt; namespace, e.g. the &lt;sec:authorize&gt; tag
                limiting certain content on a view to users with specified
                permissions.</entry>
              </row>

              <row>
                <entry>taglibs:standard - 1.1.2</entry>

                <entry>The Apache Standard Taglibs library (taglibs:standard),
                scoped compile, is an implementation of the JSP Standard Tag
                Library. In Ticket Monster, this permits us to use the
                &lt;c&gt; and &lt;fmt&gt; namespaces within our JSPs.</entry>
              </row>

              <row>
                <entry>org.apache.tiles:tiles-jsp - 2.1.3</entry>

                <entry>This library is included with scope compile for the use
                of the &lt;tiles&gt; namespace. For example, in Ticket
                Monster, this library is used to create the standard.jsp
                Apache Tiles template, which is the definition for all JSP web
                views.</entry>
              </row>

              <row>
                <entry>org.codehaus.jackson:jackson-mapper-asl - 1.6.4</entry>

                <entry>The Jackson mapper-asl dependency is a Spring
                dependency, so it is scoped compile as well. It is responsible
                for handling the Java/JSON conversion for Ticket Monster's
                JSON methods.</entry>
              </row>

              <row>
                <entry>org.codehaus.jackson:jackson-core-asl - 1.6.4</entry>

                <entry>The Jackson core-asl dependency is a Spring dependency,
                and is thus brought in to the application at compile time as
                well. It is responsible for handling the Java/JSON conversion
                for Ticket Monster's JSON methods.</entry>
              </row>

              <row>
                <entry>org.infinispan:infinispan-spring - 5.1.0.BETA2</entry>

                <entry>The infinispan-spring library is a dependency, with
                scope compile, that is necessary for the use of the Infinispan
                cache container that is provided with JBoss Application Server
                7. Configuration of this cache implementation can be viewed in
                src/main/resources/META-INF/spring/applicationContextCache.xml.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>Further, to properly deploy the Ticket Monster application on
      JBoss AS 7, we must manipulate the class-loading. To control
      class-loading in a finer way, we use a JBoss specific deployment
      descriptor file jboss-deployment-structure.xml, located in
      src/main/webapp/WEB-INF. This file can be used to add dependencies,
      define additional modules, or exclude dependencies which are normally
      automatically added. In Ticket Monster, this file is only used to add
      dependencies explicitly. The dependencies added are
      org.apache.commons.logging, for logging purposes; org.infinispan, for
      the implementation of an Infinispan cache; and
      org.jboss.ironjacamar.jdbcadapters, to connect the Java EE platform to
      the embedded JDBC database.</para>
    </section>
  </chapter>

  <chapter>
    <title>Using JBoss and Spring Together</title>

    <para>This chapter will describe the various Spring and JBoss integration
    use cases covered by the application and how are they implemented in
    Ticket Monster.</para>

    <section>
      <title>Integration of JBoss and Spring Use Cases</title>

      <para>The Ticket Monster application covers a number of JBoss and Spring
      integration use cases. The scenarios selected for this example are
      focusing on using the Java EE 6 services provided by the JBoss
      Application Server in Spring applications. Below, the various use cases
      are grouped into categories:</para>

      <table>
        <title>Overview of Spring/JBoss Integration Use Cases</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Category</entry>

              <entry align="center">Use case</entry>

              <entry align="center">How does this involve JBoss AS</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Persistence</entry>

              <entry>Spring/JPA integration</entry>

              <entry>The Persistence Unit is deployed by JBoss and retrieved
              from JNDI to be injected into Spring beans. PersistenceContext
              is shared with surrounding EJBs (if any).</entry>
            </row>

            <row>
              <entry>Testing</entry>

              <entry>Unit-testing components that have managed infrastructure
              dependencies</entry>

              <entry>The DataSource and EntityManager are managed by JBoss and
              acquired from JNDI by Spring when the application is running. In
              the case of JBoss, developers can test their code in isolation
              using Spring-specific replacements that 'simulate' the JBoss
              environment.</entry>
            </row>

            <row>
              <entry>Business Logic</entry>

              <entry>Spring-based service beans</entry>

              <entry>The business services are Spring-managed and wrapped into
              transactions managed by Spring's interceptors. The
              TransactionManager in use is the JTATransactionManager using
              JBoss Transactions provided in JBoss AS.</entry>
            </row>

            <row>
              <entry>User Interface</entry>

              <entry>Spring MVC, JSON, and jQuery UI</entry>

              <entry>The application uses Spring MVC to create the web
              controllers, as well as using JSON services to update
              information displayed in the web view. jQuery UI, specifically
              Accordion, is used for some particular displays.</entry>
            </row>

            <row>
              <entry>Aspect-Oriented Programming</entry>

              <entry>Spring-based weaving of POJO aspects</entry>

              <entry>This use case does not have any JBoss AS-specific
              functionality.</entry>
            </row>

            <row>
              <entry>Security</entry>

              <entry>Application-server pre-authentication</entry>

              <entry>The application uses Spring Security for authorizing
              access to resources. Authentication is provided by the
              application server.</entry>
            </row>

            <row>
              <entry>Caching</entry>

              <entry>Spring-based management of cache</entry>

              <entry>The application uses the Spring SimpleCacheManager to
              retrieve a ConcurrentMapCache, which tracks seat allocations,
              for future reservations. This CacheManager can be obtained using
              either a bean definition or Infinispan.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Domain Model</title>

      <para>The package org.jboss.spring.ticketmonster.domain does not include
      any classes which interact directly with Spring. However, the domain
      package is important as it contains definitions for the application's
      entities.</para>

      <figure>
        <title>Ticket Monster Entities</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="???" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>A more detailed description of many of the entities is not
      provided, as the only other members which they have are
      primitives.</para>
    </section>

    <section>
      <title>Persistence Implementation - JPA</title>

      <para>The application's persistence strategy is implemented using the
      Java Persistence API (JPA). Persistence-related classes are defined in
      the org.jboss.spring.ticketmonster.repo package. This package includes
      implementations of repository interfaces for database access, and Spring
      context definition fragments that can be re-used elsewhere in the
      application. This section describes how JPA was used to implement
      persistence in the Ticket Monster example, as well as how the various
      repository implementations can be unit tested with the JPA
      implementation.</para>

      <section>
        <title>JPA Implementation</title>

        <para>JPA provides a parametrized superclass that is Spring-agnostic
        as well (except for the usage of the Spring @Autowired annotation -
        which can be replaced by a simple setter if any reference to Spring
        needs to be removed). For database access, the JPA implementation uses
        the JPA EntityManager (javax.persistence.EntityManager) interface to
        query the database and retrieve results. The JPA Persistence Unit (and
        subsequent EntityManager) are created by the JBoss Application Server,
        not by Spring (though the EntityManager is injected by Spring, it is
        acquired from JNDI). The Spring application context configuration
        fragments can be found in the following locations:</para>

        <itemizedlist>
          <listitem>
            <para>src/main/resources/META-INF/spring/ticketmonster-business-context.xml
            - contains Spring bean definitions for repository of
            implementations, assumes that the EntityManager bean definition is
            contained in the infrastructure.xml file</para>
          </listitem>

          <listitem>
            <para>src/main/resources/META-INF/spring/infrastructure.xml -
            contains definitions for infrastructure-related Spring beans, such
            as the data source, EntityManager, and JTA transaction
            manager</para>
          </listitem>

          <listitem>
            <para>src/main/resources/META-INF/persistence.xml - contains the
            persistence unit definition for ticketmonsterPU</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>JUnit Testing of the Repositories</title>

        <para>With the infrastructure of the application coupled so tightly to
        the application server, we are presented with the issue of thoroughly
        unit testing and debugging the repositories in isolation, before they
        are fully integrated with the rest of the application.</para>

        <para>If at deployment, we use services provided by the JBoss
        Application Server, such as the data source, EntityManager, and
        transaction manager, then for the unit tests, we will use an embedded
        data source, Spring's ability to create a LocalEntityManager, and its
        local transaction manager capabilities.</para>

        <para>For this, we use the spring-test-infrastructure module, a
        test-scoped dependency in the project's pom. This module contains the
        modules used for setting up an embedded database (producing a
        DataSource that can be injected into the
        LocalContainerEntityManagerFactoryBean). The localized EntityManager
        and transaction manager definitions is located in the
        src/test/resources/test-context.xml file, while other definitions
        related to the JUnit test context can be found in the
        src/test/resources/META-INF directory.</para>

        <para>The JUnit tests are located in the
        org.jboss.spring.ticketmonster.test package of the src/test/java
        directory. The unit tests will use the test context and local
        infrastructure XML files as in the following example:<informalexample>
            <programlisting>@ContextConfiguration(locations = {"classpath:test-context.xml",
"classpath:/META-INF/spring/ticketmonster-business-context.xml",
"classpath:/META-INF/test-bookingState.xml"})
@RunWith(SpringJUnit4ClassRunner.class)
@Transactional
@TransactionConfiguration(defaultRollback=true)
public class TestTicketMonsterRepository() {
/* JUnit tests */
}</programlisting>

            <para>This configuration reuses the 'application-specific' context
            configuration fragment, i.e. the repository bean definitions, as
            well as two test-specific (or otherwise said local) context
            configuration fragments in order to create a Spring context in
            isolation. Thus, the functionality provided by the repositories
            can be tested outside the running application.</para>
          </informalexample></para>
      </section>
    </section>

    <section>
      <title>Service Layer</title>

      <para>On top of the domain and persistence layer sits the service layer
      of the application. Its role is to co-ordinate the domain objects and
      repositories in order to perform higher level operations. This is also
      the layer which provides transaction demarcation, using Spring's
      @Transactional annotation. One consideration for which transaction
      demarcation should be done at service level is to ensure that the
      changes made by service operations are atomic. Otherwise, concurrent
      operations may leave the application data in an inconsistent state.
      Demarcating transactions at the repository/DAO level should be done
      carefully, taking into consideration that multiple repository/DAO
      invocations that are not surrounded by a wrapping transactions will
      execute in separate transactional contexts.</para>

      <para>In the Ticket Monster application, the service layer consists of
      the ReservationManager and AllocationManager interfaces. These
      interfaces are implemented using Spring; both the interfaces themselves
      and the classes implementing them can be found in the
      org.jboss.spring.ticketmonster.service package.</para>

      <para>This Spring-based service layer exposes a number of service beans
      that can be consumed by the UI, which are injected with the beans
      defined in the persistence layer, in
      src/main/ticketmonster-business-context.xml, much like the repositories.
      Given how this is a fairly straightforward Spring configuration, we will
      not insist much on this topic, except for outlining that this is the
      level where transaction demarcation is provided by the use of the
      appropriate Spring annotations. Spring Security is also used to ensure
      that only users with the appropriate authorization can make changes to
      the cache and database. For example, users who are just browsing Ticket
      Monster for event information should not be able to reserve seats, thus
      allocating them in the cache, unless they have logged in to an account
      with Ticket Monster.</para>
    </section>

    <section>
      <title>Presentation Layer</title>

      <para>The Ticket Monster web application illustrates how we can
      integrate Spring and Java EE technologies in the presentation layer, in
      this case using Spring MVC to create the web controllers and JSF to
      handle display of the various pages:</para>

      <section>
        <title>Configuration of Spring MVC and Apache Tiles</title>

        <para>To integrate the UI and Spring MVC, we use the Spring provided
        DispatcherServlet, defined in src/main/webapp/WEB-INF/web.xml as shown
        in the snippet of code below:<informalexample>
            <programlisting>&lt;servlet&gt;
    &lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/spring-webflow-config.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;


&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/flow/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
          </informalexample></para>

        <para>The Spring business application is bootstrapped by the
        ContextLoaderListener, a Spring web class, defined in
        /WEB-INF/web.xml. The Spring configuration file in use is
        /WEB-INF/ticketmonster-mvc-context.xml, which defines a number of
        Spring beans that are used directly in the web tier by the JSP pages.
        These beans include a ResourceBundleMessageSource, so that messaging
        macros can be used in JSP, and a ContentNegotiatingViewResolver.
        Further, web.xml includes several bean definitions required in order
        to properly configure Apache Tiles; these include a TilesViewResolver
        to map view names to Tiles Definitions and a TilesConfigurer to
        initialize the Tiles CompositeView system. The bean definitions are
        included below:<informalexample>
            <programlisting>&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.tiles2.TilesViewResolver"&gt;
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.tiles2.TilesView"/&gt;
    &lt;property name="order" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles2.TilesConfigurer"&gt;
    &lt;property name="definitions"&gt;
        &lt;list&gt;
            &lt;value&gt;/WEB-INF/**/layouts.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/**/views.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>Spring MVC</title>

        <para>Ticket Monster provides an example of how Spring can be
        integrated with the JBoss Application Server, using Spring for the web
        tier and presentation layer of the application. This is accomplished
        by using the Spring Web MVC framework. Spring MVC allows us to easily
        use annotations to denote controllers, map controllers to various
        views, create GET and POST methods, to name just a few functions of
        Spring MVC. The Spring MVC beans are defined in the
        /WEB-INF/ticketmonster-mvc-context.xml file, referenced by the
        DispatcherServlet referenced in the previous section. First, we must
        add some XML elements to ticketmonster-mvc-context.xml in order to
        take full advantage of Spring MVC, as shown below:<informalexample>
            <programlisting>&lt;context:component-scan base-package="org.jboss.spring.ticketmonster.mvc"/&gt;

&lt;mvc:annotation-driven /&gt;

&lt;mvc:resources mapping="/static/**" location="/" /&gt;

&lt;mvc:default-servlet-handler/&gt;</programlisting>
          </informalexample></para>

        <para>The above elements are necessary for the following
        reasons:<itemizedlist>
            <listitem>
              <para>&lt;mvc:annotation-driven /&gt; advises that the
              application to search for Spring MVC annotations to indicate
              controllers, request mappings, etc.</para>
            </listitem>

            <listitem>
              <para>&lt;context:component-scan
              base-package="org.jboss.spring.ticketmonster.mvc"/&gt; indicates
              where to scan for Spring MVC annotations (in this case the
              org.jboss.spring.ticketmonster.mvc package)</para>
            </listitem>

            <listitem>
              <para>&lt;mvc:resources mapping="/static/**" location="/" /&gt;
              maps static resources, such as CSS files, images, etc. to the
              fake URL '/static/**', so that the servlet is mapped to
              '/'</para>
            </listitem>

            <listitem>
              <para>&lt;mvc:default-servlet-handler/&gt; allows the
              DispatcherServlet to be mapped to '/', overriding the
              container's default servlet</para>
            </listitem>
          </itemizedlist></para>

        <para>The Ticket Monster application uses Spring 3 MVC
        annotation-based configuration, exemplified below via a skeleton
        version of the BookingFormController:</para>

        <informalexample>
          <programlisting>@Controller
@RequestMapping("/bookings")
public class BookingFormController {

/* Injection of repositories and service managers */

    @RequestMapping(value = "/{id}", method=RequestMethod.GET)
    public String viewShow(@PathVariable("id") Long id, Model model) {}

    @RequestMapping(value="/checkout", method=RequestMethod.POST)
    public String onSubmit(Model model) {}

    @RequestMapping(value = "/allocate", method=RequestMethod.GET, produces = "application/json")
    public @ResponseBody boolean updateAllocation(Long showId, Long priceCategoryId, int quantity) {}
}</programlisting>
        </informalexample>

        <para>The above skeleton of code demonstrates the use of some very
        important annotations when using Spring MVC to handle the web tier of
        an application. These annotations include:<itemizedlist>
            <listitem>
              <para>@Controller - designates the annotated class as a Spring
              MVC controller</para>
            </listitem>

            <listitem>
              <para>@RequestMapping - maps the specific class and/or function
              to a URL, relative to the servlet path</para>
            </listitem>

            <listitem>
              <para>RequestMethod - though not an annotation per se, it is
              still important as it designates the specific method as a GET,
              POST, etc.</para>
            </listitem>

            <listitem>
              <para>@PathVariable - binds an element from a specified URL path
              to a variable, e.g. bookings/{id} binds the value of id to a
              variable for a GET method</para>
            </listitem>
          </itemizedlist></para>

        <para>Note that, although not used in this example, method parameters
        can also be specified via the URL using the @RequestParameter
        annotation. For example, in the EventController class, the getEvents()
        method first checks if any parameters were specified regarding which
        events to retrieve. In that example, the user can specify parameters
        such as 'major' by navigating to URL like '/events?major=true' and the
        getEvents() method would retrieve all events that were marked as
        major.</para>
      </section>

      <section>
        <title>JavaScript Object Notation</title>

        <para>JavaScript Object Notation (JSON) is a subset of the JavaScript
        language used to represent simple objects like associative arrays and
        basic data structures. In Ticket Monster, JSON services are mapped to
        the URLs listed below for the described purposes (the JSP file with
        the JSON service definition is listed in parentheses):<itemizedlist>
            <listitem>
              <para>/shows?eventId={eventId}&amp;venueId={venueId} - retrieves
              the show times for a given event and venue pair, as specified by
              the event and venue IDs in the URL (eventDetails.jsp)</para>
            </listitem>

            <listitem>
              <para>/venues/{venueId} - retrieves all relevant information
              about the venue specified by the given ID, such as the venue
              address and description</para>
            </listitem>

            <listitem>
              <para>/categories?eventId={eventId}&amp;venueId={venueId} -
              retrieves information on all seating sections for shows with the
              given event and venue IDs (as different events at the same venue
              may have different seating layout) such as section names,
              available price categories along with their prices
              (eventDetails.jsp)</para>
            </listitem>

            <listitem>
              <para>/bookings/allocate?showId={showId}&amp;priceCategoryId={priceCategoryId}&amp;quantity={quantity}
              - searches the cache of seat blocks, both reserved and
              purchased, for an allocation in the price category specified by
              priceCategoryId for the show specified by showId. Before
              searching for a reservation, the JSON service first checks if
              there are any other seating requests by that User within that
              section, in which case it combines the requests from the various
              categories into one large request for that section. Finally,
              this method searches for an existing reservation, trying to
              update it if it exists and creating a new reservation if it does
              not (showDetails.jsp)</para>
            </listitem>
          </itemizedlist></para>

        <para>JSON services are implemented by creating a JavaScript function,
        and passing the parameters of the service to the JavaScript function.
        Then, we create a String variable with the targeted URL of the JSON
        service to get the results of the method call, as shown in this
        example from showDetails.jsp:<informalexample>
            <programlisting>function updateReservation(showId, priceCategoryId, quantity) {
    baseUrl = '&lt;c:url value="/bookings/allocate?"/&gt;';
    jQuery.getJSON(baseUrl + "showId=" + showId + "&amp;priceCategoryId=" + priceCategoryId + "&amp;quantity=" + quantity, function (result) {
        if(result == true)
            $("div#priceCategory_" + priceCategoryId).text("Available seats have been allocated.");
        else
            $("div#priceCategory_" + priceCategoryId).text("Insufficient available seats.");
    });
}</programlisting>
          </informalexample></para>

        <para>However, to properly bind the URL used in the jQuery.getJSON()
        call to a Java method, we must use some simple Spring Web annotations.
        In the @RequestMapping annotation, we must add 'produces =
        "application/json" ' to indicate that there will be a JSON service
        corresponding to the URL specified in the same annotation. As well, we
        must annotate the return type of the Java method with the
        @ResponseBody annotation so that Spring will serialize to JSON. The
        updateAllocation() method, from the BookingFormController class, is
        provided as an example of how these annotations should be used
        properly:<informalexample>
            <programlisting>@RequestMapping(value = "/allocate", method=RequestMethod.GET, produces = "application/json")
public @ResponseBody boolean updateAllocation(Long showId, Long priceCategoryId, int quantity) {
    boolean success = false;
    int sectionQuantity = 0;

    Long sectionId = showDao.findPriceCategory(priceCategoryId).getSection().getId();
    int previousQuantity = reservationManager.getBookingState().updateCategoryRequests(priceCategoryId, quantity);

    for(PriceCategoryRequest categoryRequest : reservationManager.getBookingState().getCategoryRequests()) {
        if(categoryRequest.getPriceCategory().getSection().getId().equals(sectionId)) {
            sectionQuantity += categoryRequest.getQuantity();
        }
    }

    success = reservationManager.updateSeatReservation(showId, sectionId, sectionQuantity);

    if(success == false) {
        reservationManager.getBookingState().updateCategoryRequests(priceCategoryId, previousQuantity);
    }

    return success;
}</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>jQuery UI</title>

        <para>An important feature of Ticket Monster is the ability for a user
        to view all the seating sections available at a specific venue, as
        well as the various price categories available in each section. To do
        this, Ticket Monster uses the Accordion feature of jQuery UI.
        Accordion is a standard jQuery widget which, given menu of options,
        displays each option of the menu as its own separate header. Each
        header is also its own dropdown, so that, on click, each menu option's
        content will be displayed as a dropdown. One important feature of
        jQuery Accordion is that only one dropdown can be active at a time;
        thus, clicking a different header will cause the currently displayed
        content to collapse.</para>

        <para>In Ticket Monster, jQuery Accordion is implemented on each
        individual event's view page, i.e. /events/{id} where {id} represents
        the selected event's ID. To implement jQuery Accordion, jQuery UI must
        be included in the src/main/webapp directory of the project, as
        jquery-ui-1.8.14.custom.min.js is in Ticket Monster. Once this is
        included, Accordion only requires some simple HTML, as demonstrated in
        the example below, taken from the jQuery UI website:<informalexample>
            <programlisting>&lt;div id="accordion&gt;
    &lt;h3&gt;&lt;a href="#"&gt;First Header&lt;/a&gt;&lt;/h3&gt;
    &lt;div&gt;First menu option content&lt;/div&gt;
    &lt;h3&gt;&lt;a href="#"&gt;Second Header&lt;/a&gt;&lt;/h3&gt;
    &lt;div&gt;Second menu option content&lt;/div&gt;
&lt;/div&gt;</programlisting>
          </informalexample></para>

        <para>In Ticket Monster, the Accordion section, located in
        eventDetails.jsp, is implemented using a JavaScript, as a JSON service
        is required to populate the Accordion based on the items selected in a
        dropdown menu. JSON services are very important to Ticket Monster for
        a variety of purposes, such as retrieving a show's price categories as
        well as updating or creating seat reservations.</para>
      </section>
    </section>

    <section>
      <title>Enterprise Integration Features</title>

      <para>The Ticket Monster application provides a few other examples of
      integrating Spring and JBoss. Since all the features are Spring-based,
      they have been included as business services of the web application. All
      the definitions for the following examples can be found in the
      src/main/resources/META-INF/spring directory.</para>

      <section>
        <title>Caching</title>

        <para>An important feature of Ticket Monster is the ability for
        multiple users to reserve tickets for the same show at the same time.
        To provide this functionality, the application must keep track of all
        seat blocks that have been reserved and purchased for a given show at
        all times. However, it would be impractical to persist all of this
        data to the Ticket Monster database. Instead, we take advantage of
        another useful feature provided in Spring 3.1, the Spring Cache
        Abstraction, either by declaring a CacheManager bean or using the
        CacheManager packaged with JBoss AS 7.</para>

        <section>
          <title>CacheManager Configuration</title>

          <para>The Spring Cache Abstraction provides a variety of methods for
          caching, such as annotating entities as @Cacheable and methods as
          @CacheEvict, or dealing directly with a Cache object (often either
          an Ehcache or Concurrent Map Cache) retrieved by a CacheManager. In
          the Ticket Monster example, we will inject a Cache object, declared
          as a bean in /META-INF/spring/ticketmonster-business-context.xml;
          this way, we can retrieve the cache of reservations using this
          CacheManager bean. The CacheManager bean definition, as well as the
          cache configuration, are included below:<informalexample>
              <programlisting>&lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt;
    &lt;property name="caches"&gt;
        &lt;set&gt;
            &lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="reservations"/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
    
&lt;bean id="defaultCache" factory-bean="cacheManager" factory-method="getCache"&gt;
    &lt;qualifier value="reservations"/&gt;
    &lt;constructor-arg value="reservations"/&gt;
&lt;/bean&gt;</programlisting>
            </informalexample></para>

          <para>In the above code, the Cache Manager bean is declared as a
          SimpleCacheManager, which is then injected into the various
          implementations of the service layer interfaces using the @Autowired
          annotation. As well, we also declare a default cache, obtained by
          call calling the getCache() method of the SimpleCacheManager with an
          argument of "reservations", which is a ConcurrentMapCache object. As
          well, the &lt;qualifier&gt; element can be used to identify the
          Cache object when it is injected into our Java classes. This is
          accomplished using the @Qualifier annotation, as demonstrated in the
          simple Cache definition below:<informalexample>
              <programlisting>@Autowired
@Qualifier("reservations")
private Cache reservationsCache;</programlisting>
            </informalexample></para>

          <para>The above definition injects the ConcurrentMapCache bean,
          defined in ticketmonster-business-context.xml, with the qualifier of
          "reservations" into the Java class where this code is placed.</para>
        </section>

        <section>
          <title>Infinispan CacheContainer</title>

          <para>JBoss Application Server 7 provides a simple Infinispan
          subsystem in the server configuration. This Infinispan subsystem can
          be used to define and configure multiple cache container elements.
          Using cache containers provided by the application server, we can
          define several caches for each cache container, and access these
          caches by retrieving a CacheManager object from the application
          server's ResourceManager. The Ticket Monster application properly
          illustrates this functionality. To set it up in one's own
          application, first we must add CacheContainer and Cache definitions
          to the server configuration file, in this case
          ${JBOSS_AS_7_HOME}/standalone/configuration/standalone.xml, as
          illustrated below:<informalexample>
              <programlisting>&lt;cache-container name="ticket-monster" default-cache="reservations"&gt;
    &lt;local-cache name="reservations"&gt;
        &lt;eviction strategy="LRU" max-entries="10000"/&gt;
        &lt;expiration max-idle="100000"/&gt;
    &lt;/local-cache&gt;
&lt;/cache-container&gt;</programlisting>
            </informalexample></para>

          <para>The above XML code should be added to the Infinispan subsystem
          of the standalone.xml file. Next, we must add a file, located in
          META-INF/spring/applicationContextCache.xml, to the application
          classpath. This file, added via the contextConfigLocation context
          parameter in WEB-INF/web.xml, provides the application context
          definition for the Infinispan cache. The contents of the
          applicationContextCache.xml file are explained
          below:<informalexample>
              <programlisting>&lt;cache:annotation-driven/&gt;

&lt;beans profile="local"&gt;
    &lt;infinispan:embedded-cache-manager/&gt;
&lt;/beans&gt;

&lt;beans profile="jboss"&gt;
    &lt;infinispan:container-cache-manager cache-container-ref="cacheContainer"/&gt;
    &lt;jee:jndi-lookup jndi-name="java:comp/env/infinispan/cacheContainer" id="cacheContainer" 
        expected-type="org.infinispan.manager.CacheContainer"/&gt;
&lt;/beans&gt;</programlisting>
            </informalexample></para>

          <para>The &lt;cache:annotation-driven/&gt; tag enables the use of
          Spring Cache Abstraction annotations. The two profile definitions
          create two separate profiles which obtain a CacheManager object in
          two different ways from the application server. The 'local' profile
          uses the CacheManager embedded in JBoss AS 7, whereas the 'jboss'
          profile uses a CacheContainer object to retrieve a CacheManager
          (hence the &lt;infinispan:container-cache-manager&gt; tag). First,
          the 'jboss' profile performs a JNDI lookup for the CacheContainer,
          which was defined earlier in standalone.xml, and the application
          server then uses this CacheContainer to get a CacheManager. To
          specify the active profile, we add the following context parameter
          to WEB-INF/web.xml:<informalexample>
              <programlisting>&lt;context-param&gt;
    &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt;
    &lt;param-value&gt;${active.profile}&lt;/param-value&gt;
&lt;/context-param&gt;</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title>Cache Lookups</title>

          <para>In order to use caching effectively, we must create a CacheKey
          class, located in org.jboss.spring.ticketmonster.domain, which can
          be uniquely associated with each object stored on the cache. In
          Ticket Monster, we cache objects using a key consisting of a show ID
          and a row ID. The actual object stored on the cache, a
          RowReservation, consists of a CacheKey object for that
          RowReservation as well as a LinkedList of SeatBlock objects,
          representing already reserved or purchased seats by their start and
          end seat. In order for objects to be stored and retrieved from the
          cache properly, we must first override the hash() and equals()
          methods of the CacheKey class, which can be generated automatically
          by JBoss Developer's Studio, as shown here:<informalexample>
              <programlisting>@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((rowId == null) ? 0 : rowId.hashCode());
    result = prime * result + ((showId == null) ? 0 : showId.hashCode());
    return result;
}

@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;

    CacheKey other = (CacheKey) obj;

    if (rowId == null) {
        if (other.rowId != null)
            return false;
    } else if (!rowId.equals(other.rowId))
        return false;
    if (showId == null) {
        if (other.showId != null)
            return false;
    } else if (!showId.equals(other.showId))
        return false;
    return true;
}</programlisting>
            </informalexample></para>

          <para>For examples of using the injected CacheManager to retrieve a
          cache, as well as manipulating the retrieved cache, code
          implementation can be found in both the SimpleReservationManager and
          SimpleAllocationManager implementations of Ticket Monster's service
          layer interfaces.</para>
        </section>
      </section>

      <section>
        <title>Aspects and Cross-Cutting Concerns</title>

        <para>Given the use cases of the Ticket Monster application, it is
        very important for the application to keep record of transaction order
        (such as which seats were reserved when and by whom) as well as
        confirmation of payment. One method of the application maintaining
        this information is to use advice on cross-cutting concerns. In Ticket
        Monster, we implement this advice using Spring Aspect-Oriented
        Programming (Spring AOP), which provides a simple set of AspectJ
        annotations that can be used to advise on the application's business
        logic. To configure Spring AOP, first we must add the following
        definition to META-INF/spring/ticketmonster-business-context.xml and
        to WEB-INF/ticketmonster-mvc-context.xml, as both application context
        files include the definitions of beans to be advised:<informalexample>
            <para><programlisting>&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</programlisting></para>
          </informalexample></para>

        <para>This simple XML tag, provided by the Spring aop namespace,
        allows us to use AspectJ annotations to create pointcuts, Advice for
        cross-cutting concerns is contained in the
        org.jboss.spring.ticketmonster.advice package. This package contains
        three separate classes, ControllerLog, ServiceLog, and RepositoryLog.
        These classes contain advice for cross-cutting concerns to deal with
        MVC controllers, service implementations, and repository
        implementations respectively. Below is an example of the use of
        AspectJ annotations to declare pointcuts and cross-cutting advice in
        Ticket Monster's RepositoryLog class:<informalexample>
            <programlisting>@Aspect
@Component
public class RepositoryLog {

    protected final Log logger = LogFactory.getLog(getClass()); 

    @Pointcut("execution(* org.jboss.spring.ticketmonster.repo.AllocationDao.populateCache(..))")
    public void cache() {
    }
    
    @Pointcut("execution(* org.jboss.spring.ticketmonster.repo.UserDao.getByName(String)) &amp;&amp; args(username)")
    public void getUser(String username) {
    }
    
    @Before("cache()")
    public void startup() {
        logger.info("Populating the reservations cache with previously made allocations that are stored in the database.");
    }
    
    @AfterThrowing("cache()")
    public void bootstrapFail() {
        logger.info("Population of the cache with allocations in the database failed.");
    }
    
    @AfterReturning("cache()")
    public void bootstrap() {
        logger.info("Successfully populated the cache with Allocation objects from the database.  Already purchased SeatBlocks have been marked as such.");
    }
    
    @AfterReturning("getUser(username)")
    public void user(String username) {
        logger.info("Retrieved User object from the database with a 'username' field of " + username + ".");
    }
}</programlisting>
          </informalexample></para>

        <para>In the above example, the @Aspect annotation indicates to the
        application that the RepositoryLog class should be scanned for
        pointcuts and cross-cutting advice. As well, the @Component annotation
        indicates that this class is a Spring-managed component. We divide the
        advice performed by Ticket Monster across a variety of classes. This
        allows us to create easily readable code, avoiding large amounts of
        code between the pointcut definition and advice on that pointcut, as
        well as add more advice classes easily. By annotating each class with
        @Component, we no longer have to declare each bean separately in
        context files. Instead, we use a Spring component scan to find any
        beans that should be added to the application context. This is
        accomplished by adding the following line to
        META-INF/spring/ticketmonster-business-context.xml:<informalexample>
            <programlisting>&lt;context:component-scan base-package="org.jboss.spring.ticketmonster.advice"/&gt;</programlisting>
          </informalexample>The @Pointcut annotation defines a pointcut, which
        specifies the joinpoint when cross-cutting advice will be applied,
        such as the execution of a particular method or within a certain type,
        to provide two examples. In the case of an execution pointcut, where
        the joinpoint occurs on the execution of a method, we use annotations
        such as @Before, @AfterReturning, @AfterThrowing, or @After, to
        indicate whether the joinpoint will occur before execution, after
        successful execution, after an exception is thrown, etc. Note that, in
        the above example, to pass a parameter to advice via the pointcut, we
        must add the parameter type to the execution designator and an args()
        designator, specifying the parameter names to be passed. As well, it
        should be mentioned that, while in this example, we only use
        cross-cutting advice to log information, aspect-oriented programming
        can be used for more complex uses, e.g. calls to methods upon
        successful completion of each transaction.</para>

        <para>It is very important to note that logging is a simple task that
        does not require Spring AOP, it could easily be done directly in the
        methods themselves. However, Spring AOP is a very powerful tool which
        can be used in a wide variety of very complex use cases. The use of
        Spring AOP in Ticket Monster simply provides an example of how to
        properly configure Spring AOP and how to implement it in simple use
        cases.</para>
      </section>

      <section>
        <title>JBoss-Authenticated Security</title>

        <para>To ensure that only authenticated users are able to make
        reservations and pay for previously reserved seats, we use Spring
        Security 3.1.0.RC2 to restrict access to certain pages of the Ticket
        Monster example. Access to the reservations and checkout page (i.e.
        all URLs of '/booking**') is restricted, as described in
        META-INF/spring/ticketmonster-security-context.xml, To enable Spring
        Security, we must first add this ticketmonster-security-context.xml
        file to the contextConfigLocation, specified as a
        &lt;context-param&gt; elementin web.xml.</para>

        <para>One level of security is added by enabling Spring Security
        annotations. Using these annotations, we can ensure that certain
        methods can only be called by users with the specified credentials.
        This is accomplished by adding the following XML code to the
        ticketmonster-security-context.xml:<informalexample>
            <para><programlisting>&lt;global-method-security pre-post-annotations="enabled"/&gt;</programlisting></para>
          </informalexample></para>

        <para>With these annotations enabled, we can then annotate methods,
        such as the methods of the ReservationManager interface, as
        @PreAuthorize("hasRole('ROLE_USER')"). By including this annotation,
        only those with the role of User, in this case those with an account
        in the Ticket Monster database, can call methods of the
        ReservationManager interface.</para>

        <para>To add another layer of security to the Ticket Monster example,
        we restrict the access to certain URLs within the Ticket Monster
        application. This is accomplished by adding intercept-url definitions
        to the ticketmonster-security-context.xml file:<informalexample>
            <programlisting>&lt;http pattern="/static/**" security="none" /&gt;

&lt;http use-expressions="true"&gt;
    &lt;intercept-url pattern="/bookings/**" access="hasRole('ROLE_USER')"/&gt;
    &lt;intercept-url pattern="/events**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/events/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/venues**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/venues/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/shows/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/categories**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/index.jsp" access="permitAll"/&gt;
    &lt;intercept-url pattern="/**" access="denyAll"/&gt;
    &lt;form-login/&gt;
    &lt;logout logout-success-url="/"/&gt;
&lt;/http&gt;</programlisting>
          </informalexample></para>

        <para>There are a few important points to note from the above section
        of code:<itemizedlist>
            <listitem>
              <para>It is essential to make sure there is no security on the
              '/static/**' URLs, otherwise no images, CSS files, etc. will be
              accessible to non-authenticated users</para>
            </listitem>

            <listitem>
              <para>An &lt;intercept-url&gt; tag should be included to cover
              each web view, even if the access is 'permitAll', though access
              can also be 'denyAll', 'hasRole('ROLE_USER'),
              'hasRole('ROLE_SUPERVISOR'), or custom-defined roles</para>
            </listitem>

            <listitem>
              <para>If JSON services are used, the correct access must be
              given to the URL of the JSON call</para>
            </listitem>

            <listitem>
              <para>The &lt;form-login/&gt; will ensure that Spring Security
              prompts for authentication before displaying a page which the
              user does not currently have authorization to view</para>
            </listitem>
          </itemizedlist></para>

        <para>Finally, we must tell Ticket Monster how to verify a user's
        credentials when they attempt to log in. For security purposes, Ticket
        Monster stores passwords as salted one-way hashes, created by Spring
        Security's StandardPasswordEncoder. Once we have encoded each
        password, we can either store the hashed passwords in the
        ticketmonster-security-context.xml file itself or in the Ticket
        Monster database, querying the database to verify credentials. This
        implementation uses the latter implementation of password encryption,
        as demonstrated by code below from the security context and database
        initialization files.<informalexample>
            <programlisting>// From ticketmonster-security-context.xml

&lt;beans:bean id="encoder" class="org.springframework.security.crypto.password.StandardPasswordEncoder"/&gt;

&lt;authentication-manager&gt;
    &lt;authentication-provider&gt;
    &lt;password-encoder ref="encoder"/&gt;
    &lt;jdbc-user-service data-source-ref="dataSource" 
        users-by-username-query="select username, password, enabled from User where username = ?"
        authorities-by-username-query="select username, 'ROLE_USER' from User where username = ?"/&gt;
    &lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;

// From import.sql

insert into User (id, username, password, enabled, firstName, lastName) values (1, 'sbryzak', '12bfe8fb06f06eedec67fb43ef6ab8c850a577db73e758c40b5fceff86d9e214c36612e430b23a5e', 'true', 'Shane', 'Bryzak');
insert into User (id, username, password, enabled, firstName, lastName) values (2, 'mbg', 'eefcbef8c277b21f88d7fa36dc7e33fbf243587de1cac2dcc4edcaa717796e7326980ad18161bd4f', 'true', 'Marius', 'Bogoevici');
insert into User (id, username, password, enabled, firstName, lastName) values (3, 'rbradley', 'e5b60370d330faeddb4aef7b34ef2877cebcfaad814e62da7e9d3abe8b3be6146410572b2f21047c', 'true', 'Ryan', 'Bradley');</programlisting>
          </informalexample></para>

        <para>For those interested in adding their own User to the database,
        the id, username, firstName, and lastName fields are self-explanatory.
        The enabled field should indicate whether the added user should have
        ROLE_USER priveleges. As well, instructions to encode passwords can be
        found in the Spring Security tutorial at
        http://static.springsource.org/spring-security/site/tutorial.html.</para>
      </section>
    </section>
  </chapter>
</book>
