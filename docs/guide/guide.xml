<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <bookinfo>
    <title>Snowdrop Ticket Monster Example Application</title>

    <subtitle>Integrating Spring with the JBoss Enterprise Application
    Platforms</subtitle>

    <productname>JBoss Web Framework Kit</productname>

    <productnumber>2.0</productnumber>

    <edition>1.0</edition>

    <pubsnumber>0</pubsnumber>

    <abstract>
      <para>This book provides a walkthrough for the Snowdrop Ticket Monster
      example application. It illustrates several use cases of the JBoss
      Enterprise Application Platform with the Spring Framework.</para>
    </abstract>

    <corpauthor>JBoss by Red Hat</corpauthor>

    <authorgroup>
      <author>
        <firstname>Ryan</firstname>

        <surname>Bradley</surname>

        <affiliation>
          <orgname>JBoss by Red Hat</orgname>
        </affiliation>

        <email>rbradley@redhat.com</email>
      </author>

      <author>
        <firstname>Marius</firstname>

        <surname>Bogoevici</surname>

        <affiliation>
          <orgname>JBoss by Red Hat</orgname>
        </affiliation>

        <email>mariusb@redhat.com</email>
      </author>
    </authorgroup>

    <pubdate>October 7, 2011</pubdate>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <section>
      <title>Feedback</title>

      <para>If you find a typographical error in this manual, or if you have
      thought of a way to make this manual better, we would love to hear from
      you! Please submit a report in JIRA: <ulink
      url="http://jira.jboss.org/">http://jira.jboss.org/</ulink> against the
      product <application>Snowdrop</application> and component
      <emphasis>Examples</emphasis>.</para>

      <para>When submitting a bug report, be sure to mention the manual's
      identifier: Snowdrop <citetitle>Ticket Monster
      Example</citetitle>.</para>

      <para>If you have a suggestion for improving the documentation, try to
      be as specific as possible when describing it. If you have found an
      error, please include the section number and some of the surrounding
      text so we can find it easily.</para>
    </section>
  </preface>

  <chapter>
    <title>Introduction</title>

    <para>The Ticket Monster application provides a real world-inspired
    example of integrating Spring with the JBoss Entprise Platforms. It is a
    web application, which illustrates several use cases through various
    combinations of components and technologies. It also illustrates how to
    use the Snowdrop libraries to provide JBoss-specific features, such as
    creating a standalone deployment of an
    <classname>ApplicationContext</classname> and using many Spring-provided
    features like security and caching.</para>

    <para>This book aims to illustrate the mechanics of using Spring with
    different Java EE 6 components in the specific context of the JBoss
    Enterprise Platforms, and to recommend methods of achieving certain
    integration goals.</para>

    <para>The Ticket Monster example is not intended as a guide to creating a
    domain model. Detailing the various layers of application and UI design is
    outside the scope of this document. As such, the example application has
    been designed to illustrate integration use cases, rather than to
    demonstrate a domain model that strictly follows principles of
    object-oriented and domain-driven design.</para>

    <section>
      <title>Prerequisites</title>

      <para>Deployment of the Ticket Monster application requires the
      following:</para>

      <itemizedlist>
        <listitem>
          <para>Java 6 JDK</para>
        </listitem>

        <listitem>
          <para>JBoss Application Server 7.0.0.Final or later</para>
        </listitem>

        <listitem>
          <para>Maven 2.0.9 or later, with appropriate repositories</para>
        </listitem>
      </itemizedlist>

      <simplesect>
        <title>Setting Up Maven Repositories</title>

        <para>The Maven project setup does not make any assumptions where the
        artifacts used in the project are coming from (which repository), as
        users may have different settings for their Maven repositories (direct
        access to community repositories, proxies, enterprise repository with
        approved artifacts). Therefore, the setup of the repositories is left
        to the user of the application.</para>

        <para>In the most simple case, this example can be built out of the
        box if the settings.xml file for the local Maven installation enables
        the repositories from Maven Central and JBoss Releases. Instructions
        for setting up the latter can be found at:
        http://community.jboss.org/wiki/MavenGettingStarted-Users.</para>

        <para>The pom.xml can be modified to include references to other
        repositories, or equivalent artifact versions (if the build
        environment uses an enterprise-wide repository in which the artifacts
        have different version numbers).</para>
      </simplesect>
    </section>

    <section>
      <title>How to Build and Run Ticket Monster</title>

      <para>This document will provide a detailed account of the application
      and its use cases. However, often, it is easier to just run the
      application to answer your questions.</para>

      <itemizedlist>
        <listitem>
          <para>Building the application</para>
        </listitem>

        <listitem>
          <para>Preparing JBoss</para>
        </listitem>

        <listitem>
          <para>Deploying the application</para>
        </listitem>

        <listitem>
          <para>Starting the application server</para>
        </listitem>
      </itemizedlist>

      <para>Below, you will find instructions on how to perform each of these
      steps.</para>

      <section>
        <title>Building the Application</title>

        <para>In this step, we build the application. Since Ticket Monster
        uses Maven, so it can be built from the command line by simple
        running:</para>

        <informalexample>
          <programlisting>mvn clean package</programlisting>

          <para>This produces a WAR file, named TicketMonster.war, under
          TicketMonster/target. The application can then be deployed by moving
          this .war file to ${JBOSS_AS_7_HOME}/standalone/deployments and then
          executing the standalone.sh script, located in
          ${JBOSS_AS_7_HOME}/bin directory. The database will be initialized
          during this process by the SQL script, import.sql, included in the
          src/main/resources directory of the Ticket Monster project. Ticket
          Monster uses Spring 3.1.0.M2 and Spring Security 3.1.0.RC2.</para>
        </informalexample>
      </section>

      <section>
        <title>Preparing JBoss</title>

        <para>In addition to building the application, the JBoss Application
        Server must also be properly configured before deploying the
        application. Specifically, this involves creating a datasource
        definition within the configuration of the JBoss Application Server.
        To accomplish this, open the standalone.xml file, located in
        ${JBOSS_AS_7_HOME}/standalone/configuration. Next, under the
        &lt;datasources&gt; element, contained within a subsystem of the
        server, add the following data source definition:</para>

        <informalexample>
          <para><programlisting>&lt;datasource jndi-name="java:jboss/datasources/TicketMonsterDS" pool-name="TicketMonsterDS"
   enabled="true" jta="true" use-java-context="true" use-ccm="true"&gt;
   &lt;connection-url&gt;
      jdbc:h2:mem:test;DB_CLOSE_DELAY=-1
   &lt;/connection-url&gt;
   &lt;driver&gt;
      h2
   &lt;/driver&gt;
   &lt;pool&gt;
      &lt;prefill&gt;
          false
      &lt;/prefill&gt;
      &lt;use-strict-min&gt;
          false
      &lt;/use-strict-min&gt;
      &lt;flush-strategy&gt;
          FailingConnectionOnly
      &lt;/flush-strategy&gt;
   &lt;/pool&gt;
   &lt;security&gt;
      &lt;user-name&gt;
          sa
      &lt;/user-name&gt;
      &lt;password&gt;
          sa
      &lt;/password&gt;
   &lt;/security&gt;
   &lt;validation&gt;
      &lt;validate-on-match&gt;
          false
      &lt;/validate-on-match&gt;
      &lt;background-validation&gt;
          false
      &lt;/background-validation&gt;
      &lt;useFastFail&gt;
          false
      &lt;/useFastFail&gt;
   &lt;/validation&gt;
&lt;/datasource&gt;</programlisting>This definition is necessary for the
          application to be create an in-memory database for the application,
          which can be retrieved via a JNDI look-up.</para>
        </informalexample>
      </section>

      <section>
        <title>Deploying the Application</title>

        <para>Copy the WAR file produced by the build to deploy folder of the
        JBoss Application Server.</para>

        <para>The WAR file is located in TicketMonster/target, and should be
        copied to ${JBOSS_AS_7_HOME}/standalone/deployments.</para>
      </section>

      <section>
        <title>Authenticated Access</title>

        <para>Accessing all views of the Ticket Monster web application
        requires the login information for users with the proper
        authorization. Specifically, the views related to booking tickets
        cannot be accessed by anyone but a User in the Ticket Monster
        database. Below are the three 'username, "password" ' pairs that come
        provided with the Ticket Monster application:<itemizedlist>
            <listitem>
              <para>rbradley, "ticketmonster"</para>
            </listitem>

            <listitem>
              <para>mbg, "marius"</para>
            </listitem>

            <listitem>
              <para>sbryzak, "original"</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>

    <section>
      <title>Ticket Monster and JBoss Developer's Studio</title>

      <para>The easiest way to gain a deeper understanding of the Ticket
      Monster web application is to examine the source code directly. This
      guide will instruct you how to import the application into JBoss
      Developer's Studio (JBDS).</para>

      <para>Ticket Monster is a Maven-based application; thus, to navigate its
      structure in JBoss Developer's Studio, you must create an Eclipse
      project for it. This can be done using the Maven Eclipse
      plugin:<informalexample>
          <programlisting>mvn eclipse:eclipse -Dwtpversion=2.0</programlisting>

          <para>Alternatively, the m2e Maven Integration for Eclipse plugin
          can be used to import the project into JBoss Developer's
          Studio.</para>
        </informalexample></para>

      <simplesect>
        <title>Importing Ticket Monster into JBDS</title>

        <para>Ticket Monster is a Maven-based project, so you can import it
        into JBDS if you have the m2eclipse Maven integration plugin
        installed, including the m2eclipse WTP extension. Installation can be
        found at http://download.eclipse.org/technology/m2e/releases/.</para>

        <para>For importing the project, go to
        'Import...'-&gt;'Maven'-&gt;'Existing Maven Projects' and select the
        top directory of the Ticket Monster example. You will be shown the
        project's pom.xml file.</para>
      </simplesect>
    </section>
  </chapter>

  <chapter>
    <title>Understanding the Application Structure</title>

    <para>This chapter will describe the business use cases covered by the
    Ticket Monster application.</para>

    <section>
      <title>Application Structure and Use Cases</title>

      <para>The Ticket Monster application is an example of an online ticket
      reseller, such as Ticketmaster. Users of Ticket Monster should be able
      to retrieve information about events from the website:<itemizedlist>
          <listitem>
            <para>View all events in the Ticket Monster database</para>
          </listitem>

          <listitem>
            <para>Query the database of events based on start date, end date,
            event category, whether it is major or not, etc.</para>
          </listitem>

          <listitem>
            <para>Retrieve event specific information such as event
            description, host venues, venue information, seating sections and
            prices, and show times</para>
          </listitem>

          <listitem>
            <para>View all venues in the Ticket Monster database</para>
          </listitem>

          <listitem>
            <para>Display all events being held at a specific venue, and
            navigate to individual event pages</para>
          </listitem>
        </itemizedlist></para>

      <para>As well, users need to reserve and purchase tickets for shows,
      i.e. occurrences of an event at a specific venue. To accomplish this,
      the application has the following requirements:<itemizedlist>
          <listitem>
            <para>Check a user's security credentials using Spring
            Security</para>
          </listitem>

          <listitem>
            <para>Reserve seats from specific sections to the current user for
            specific shows</para>
          </listitem>

          <listitem>
            <para>Manage a cache of currently reserved or purchased seats for
            shows in the Ticket Monster database</para>
          </listitem>

          <listitem>
            <para>Maintain a session-scoped object of the current user's
            reservations, allocations (i.e. purchased seats), and price of
            tickets in the user's shopping cart</para>
          </listitem>

          <listitem>
            <para>Persist purchased reservations to the database when a user
            finishes allocating seats or 'checks out'</para>
          </listitem>

          <listitem>
            <para>Display a list of all purchased seat blocks and the total
            price on the check out page</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </chapter>

  <chapter>
    <title>Using JBoss and Spring Together</title>

    <para>This chapter will describe the various Spring and JBoss integration
    use cases covered by the application and how are they implemented in
    Ticket Monster.</para>

    <section>
      <title>Integration of JBoss and Spring Use Cases</title>

      <para>The Ticket Monster application covers a number of JBoss and Spring
      integration use cases. The scenarios selected for this example are
      focusing on using the Java EE 6 services provided by the JBoss
      Application Server in Spring applications. Below, the various use cases
      are grouped into categories:</para>

      <table>
        <title>Overview of Spring/JBoss Integration Use Cases</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Category</entry>

              <entry align="center">Use case</entry>

              <entry align="center">How does this involve JBoss AS</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Persistence</entry>

              <entry>Spring/JPA integration</entry>

              <entry>The Persistence Unit is deployed by JBoss and retrieved
              from JNDI to be injected into Spring beans. PersistenceContext
              is shared with surrounding EJBs (if any).</entry>
            </row>

            <row>
              <entry>Testing</entry>

              <entry>Unit-testing components that have managed infrastructure
              dependencies</entry>

              <entry>The DataSource and EntityManager are managed by JBoss and
              acquired from JNDI by Spring when the application is running. In
              the case of JBoss, developers can test their code in isolation
              using Spring-specific replacements that 'simulate' the JBoss
              environment.</entry>
            </row>

            <row>
              <entry>Business Logic</entry>

              <entry>Spring-based service beans</entry>

              <entry>The business services are Spring-managed and wrapped into
              transactions managed by Spring's interceptors. The
              TransactionManager in use is the JTATransactionManager using
              JBoss Transactions provided in JBoss AS.</entry>
            </row>

            <row>
              <entry>User Interface</entry>

              <entry>Spring MVC, JSON, and jQuery UI</entry>

              <entry>The application uses Spring MVC to create the web
              controllers, as well as using JSON services to update
              information displayed in the web view. jQuery UI, specifically
              Accordion, is used for some particular displays.</entry>
            </row>

            <row>
              <entry>Aspect-Oriented Programming</entry>

              <entry>Spring-based weaving of POJO aspects</entry>

              <entry>This use case does not have any JBoss AS-specific
              functionality.</entry>
            </row>

            <row>
              <entry>Security</entry>

              <entry>Application-server pre-authentication</entry>

              <entry>The application uses Spring Security for authorizing
              access to resources. Authentication is provided by the
              application server.</entry>
            </row>

            <row>
              <entry>Caching</entry>

              <entry>Spring-based management of cache</entry>

              <entry>The application uses the Spring Simple Cache Manager to
              retrieve a Concurrent Map cache, which tracks seat allocations,
              for future reservations.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Domain Model</title>

      <para>The package org.jboss.spring.ticketmonster.domain does not include
      any classes which interact directly with Spring. However, the domain
      package is important as it contains definitions for the application's
      entities.</para>

      <figure>
        <title>Ticket Monster Entities</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="???" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>A more detailed description of many of the entities is not
      provided, as the only other members which they have are
      primitives.</para>
    </section>

    <section>
      <title>Persistence Implementation - JPA</title>

      <para>The application's persistence strategy is implemented using the
      Java Persistence API (JPA). Persistence-related classes are defined in
      the org.jboss.spring.ticketmonster.repo package. This package includes
      implementations of repository interfaces for database access, and Spring
      context definition fragments that can be re-used elsewhere in the
      application. This section describes how JPA was used to implement
      persistence in the Ticket Monster example, as well as how the various
      repository implementations can be unit tested with the JPA
      implementation.</para>

      <section>
        <title>JPA Implementation</title>

        <para>JPA provides a parametrized superclass that is Spring-agnostic
        as well (except for the usage of the Spring @Autowired annotation -
        which can be replaced by a simple setter if any reference to Spring
        needs to be removed). For database access, the JPA implementation uses
        the JPA EntityManager (javax.persistence.EntityManager) interface to
        query the database and retrieve results. The JPA Persistence Unit (and
        subsequent EntityManager) are created by the JBoss Application Server,
        not by Spring (though the EntityManager is injected by Spring, it is
        acquired from JNDI). The Spring application context configuration
        fragments can be found in the following locations:</para>

        <itemizedlist>
          <listitem>
            <para>src/main/resources/META-INF/spring/ticketmonster-business-context.xml
            - contains Spring bean definitions for repository of
            implementations, assumes that the EntityManager bean definition is
            contained in the infrastructure.xml file</para>
          </listitem>

          <listitem>
            <para>src/main/resources/META-INF/spring/infrastructure.xml -
            contains definitions for infrastructure-related Spring beans, such
            as the data source, EntityManager, and JTA transaction
            manager</para>
          </listitem>

          <listitem>
            <para>src/main/resources/META-INF/persistence.xml - contains the
            persistence unit definition for ticketmonsterPU</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>JUnit Testing of the Repositories</title>

        <para>With the infrastructure of the application coupled so tightly to
        the application server, we are presented with the issue of thoroughly
        unit testing and debugging the repositories in isolation, before they
        are fully integrated with the rest of the application.</para>

        <para>If at deployment, we use services provided by the JBoss
        Application Server, such as the data source, EntityManager, and
        transaction manager, then for the unit tests, we will use an embedded
        data source, Spring's ability to create a LocalEntityManager, and its
        local transaction manager capabilities.</para>

        <para>For this, we use the spring-test-infrastructure module, a
        test-scoped dependency in the project's pom. This module contains the
        modules used for setting up an embedded database (producing a
        DataSource that can be injected into the
        LocalContainerEntityManagerFactoryBean). The localized EntityManager
        and transaction manager definitions is located in the
        src/test/resources/test-context.xml file, while other definitions
        related to the JUnit test context can be found in the
        src/test/resources/META-INF directory.</para>

        <para>The JUnit tests are located in the
        org.jboss.spring.ticketmonster.test package of the src/test/java
        directory. The unit tests will use the test context and local
        infrastructure XML files as in the following example:<informalexample>
            <programlisting>@ContextConfiguration(locations = {"classpath:test-context.xml",
"classpath:/META-INF/spring/ticketmonster-business-context.xml",
"classpath:/META-INF/test-bookingState.xml"})
@RunWith(SpringJUnit4ClassRunner.class)
@Transactional
@TransactionConfiguration(defaultRollback=true)
public class TestTicketMonsterRepository() {
/* JUnit tests */
}</programlisting>

            <para>This configuration reuses the 'application-specific' context
            configuration fragment, i.e. the repository bean definitions, as
            well as two test-specific (or otherwise said local) context
            configuration fragments in order to create a Spring context in
            isolation. Thus, the functionality provided by the repositories
            can be tested outside the running application.</para>
          </informalexample></para>
      </section>
    </section>

    <section>
      <title>Service Layer</title>

      <para>On top of the domain and persistence layer sits the service layer
      of the application. Its role is to co-ordinate the domain objects and
      repositories in order to perform higher level operations. This is also
      the layer which provides transaction demarcation, using Spring's
      @Transactional annotation. One consideration for which transaction
      demarcation should be done at service level is to ensure that the
      changes made by service operations are atomic. Otherwise, concurrent
      operations may leave the application data in an inconsistent state.
      Demarcating transactions at the repository/DAO level should be done
      carefully, taking into consideration that multiple repository/DAO
      invocations that are not surrounded by a wrapping transactions will
      execute in separate transactional contexts.</para>

      <para>In the Ticket Monster application, the service layer consists of
      the ReservationManager and AllocationManager interfaces. These
      interfaces are implemented using Spring; both the interfaces themselves
      and the classes implementing them can be found in the
      org.jboss.spring.ticketmonster.service package.</para>

      <para>This Spring-based service layer exposes a number of service beans
      that can be consumed by the UI, which are injected with the beans
      defined in the persistence layer, in
      src/main/ticketmonster-business-context.xml, much like the repositories.
      Given how this is a fairly straightforward Spring configuration, we will
      not insist much on this topic, except for outlining that this is the
      level where transaction demarcation is provided by the use of the
      appropriate Spring annotations. Spring Security is also used to ensure
      that only users with the appropriate authorization can make changes to
      the cache and database. For example, users who are just browsing Ticket
      Monster for event information should not be able to reserve seats, thus
      allocating them in the cache, unless they have logged in to an account
      with Ticket Monster.</para>
    </section>

    <section>
      <title>Presentation Layer</title>

      <para>The Ticket Monster web application illustrates how we can
      integrate Spring and Java EE technologies in the presentation layer, in
      this case using Spring MVC to create the web controllers and JSF to
      handle display of the various pages:</para>

      <section>
        <title>Configuration of Spring MVC and Apache Tiles</title>

        <para>To integrate the UI and Spring MVC, we use the Spring provided
        DispatcherServlet, defined in src/main/webapp/WEB-INF/web.xml as shown
        in the snippet of code below:<informalexample>
            <programlisting>&lt;servlet&gt;
    &lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/spring-webflow-config.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;


&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/flow/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
          </informalexample></para>

        <para>The Spring business application is bootstrapped by the
        ContextLoaderListener, a Spring web class, defined in
        /WEB-INF/web.xml. The Spring configuration file in use is
        /WEB-INF/ticketmonster-mvc-context.xml, which defines a number of
        Spring beans that are used directly in the web tier by the JSP pages.
        These beans include a ResourceBundleMessageSource, so that messaging
        macros can be used in JSP, and a ContentNegotiatingViewResolver.
        Further, web.xml includes several bean definitions required in order
        to properly configure Apache Tiles; these include a TilesViewResolver
        to map view names to Tiles Definitions and a TilesConfigurer to
        initialize the Tiles CompositeView system. The bean definitions are
        included below:<informalexample>
            <programlisting>&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.tiles2.TilesViewResolver"&gt;
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.tiles2.TilesView"/&gt;
    &lt;property name="order" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles2.TilesConfigurer"&gt;
    &lt;property name="definitions"&gt;
        &lt;list&gt;
            &lt;value&gt;/WEB-INF/**/layouts.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/**/views.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>Spring MVC</title>

        <para>Ticket Monster provides an example of how Spring can be
        integrated with the JBoss Application Server, using Spring for the web
        tier and presentation layer of the application. This is accomplished
        by using the Spring Web MVC framework. Spring MVC allows us to easily
        use annotations to denote controllers, map controllers to various
        views, create GET and POST methods, to name just a few functions of
        Spring MVC. The Spring MVC beans are defined in the
        /WEB-INF/ticketmonster-mvc-context.xml file, referenced by the
        DispatcherServlet referenced in the previous section. First, we must
        add some XML elements to ticketmonster-mvc-context.xml in order to
        take full advantage of Spring MVC, as shown below:<informalexample>
            <programlisting>&lt;context:component-scan base-package="org.jboss.spring.ticketmonster.mvc"/&gt;

&lt;mvc:annotation-driven /&gt;

&lt;mvc:resources mapping="/static/**" location="/" /&gt;

&lt;mvc:default-servlet-handler/&gt;</programlisting>
          </informalexample></para>

        <para>The above elements are necessary for the following
        reasons:<itemizedlist>
            <listitem>
              <para>&lt;mvc:annotation-driven /&gt; advises that the
              application to search for Spring MVC annotations to indicate
              controllers, request mappings, etc.</para>
            </listitem>

            <listitem>
              <para>&lt;context:component-scan
              base-package="org.jboss.spring.ticketmonster.mvc"/&gt; indicates
              where to scan for Spring MVC annotations (in this case the
              org.jboss.spring.ticketmonster.mvc package)</para>
            </listitem>

            <listitem>
              <para>&lt;mvc:resources mapping="/static/**" location="/" /&gt;
              maps static resources, such as CSS files, images, etc. to the
              fake URL '/static/**', so that the servlet is mapped to
              '/'</para>
            </listitem>

            <listitem>
              <para>&lt;mvc:default-servlet-handler/&gt; allows the
              DispatcherServlet to be mapped to '/', overriding the
              container's default servlet</para>
            </listitem>
          </itemizedlist></para>

        <para>The Ticket Monster application uses Spring 3 MVC
        annotation-based configuration, exemplified below via a skeleton
        version of the BookingFormController:</para>

        <informalexample>
          <programlisting>@Controller
@RequestMapping("/bookings")
public class BookingFormController {

/* Injection of repositories and service managers */

    @RequestMapping(value = "/{id}", method=RequestMethod.GET)
    public String viewShow(@PathVariable("id") Long id, Model model) {}

    @RequestMapping(value="/checkout", method=RequestMethod.POST)
    public String onSubmit(Model model) {}

    @RequestMapping(value = "/allocate", method=RequestMethod.GET, produces = "application/json")
    public @ResponseBody boolean updateAllocation(Long showId, Long priceCategoryId, int quantity) {}
}</programlisting>
        </informalexample>

        <para>The above skeleton of code demonstrates the use of some very
        important annotations when using Spring MVC to handle the web tier of
        an application. These annotations include:<itemizedlist>
            <listitem>
              <para>@Controller - designates the annotated class as a Spring
              MVC controller</para>
            </listitem>

            <listitem>
              <para>@RequestMapping - maps the specific class and/or function
              to a URL, relative to the servlet path</para>
            </listitem>

            <listitem>
              <para>RequestMethod - though not an annotation per se, it is
              still important as it designates the specific method as a GET,
              POST, etc.</para>
            </listitem>

            <listitem>
              <para>@PathVariable - binds an element from a specified URL path
              to a variable, e.g. bookings/{id} binds the value of id to a
              variable for a GET method</para>
            </listitem>
          </itemizedlist></para>

        <para>Note that, although not used in this example, method parameters
        can also be specified via the URL using the @RequestParameter
        annotation. For example, in the EventController class, the getEvents()
        method first checks if any parameters were specified regarding which
        events to retrieve. In that example, the user can specify parameters
        such as 'major' by navigating to URL like '/events?major=true' and the
        getEvents() method would retrieve all events that were marked as
        major.</para>
      </section>

      <section>
        <title>JavaScript Object Notation</title>

        <para>JavaScript Object Notation (JSON) is a subset of the JavaScript
        language used to represent simple objects like associative arrays and
        basic data structures. In Ticket Monster, JSON services are mapped to
        the URLs listed below for the described purposes (the JSP file with
        the JSON service definition is listed in parentheses):<itemizedlist>
            <listitem>
              <para>/shows?eventId={eventId}&amp;venueId={venueId} - retrieves
              the show times for a given event and venue pair, as specified by
              the event and venue IDs in the URL (eventDetails.jsp)</para>
            </listitem>

            <listitem>
              <para>/venues/{venueId} - retrieves all relevant information
              about the venue specified by the given ID, such as the venue
              address and description</para>
            </listitem>

            <listitem>
              <para>/categories?eventId={eventId}&amp;venueId={venueId} -
              retrieves information on all seating sections for shows with the
              given event and venue IDs (as different events at the same venue
              may have different seating layout) such as section names,
              available price categories along with their prices
              (eventDetails.jsp)</para>
            </listitem>

            <listitem>
              <para>/bookings/allocate?showId={showId}&amp;priceCategoryId={priceCategoryId}&amp;quantity={quantity}
              - searches the cache of seat blocks, both reserved and
              purchased, for an allocation in the price category specified by
              priceCategoryId for the show specified by showId. Before
              searching for a reservation, the JSON service first checks if
              there are any other seating requests by that User within that
              section, in which case it combines the requests from the various
              categories into one large request for that section. Finally,
              this method searches for an existing reservation, trying to
              update it if it exists and creating a new reservation if it does
              not (showDetails.jsp) </para>
            </listitem>
          </itemizedlist></para>

        <para>JSON services are implemented by creating a JavaScript function,
        and passing the parameters of the service to the JavaScript function.
        Then, we create a String variable with the targeted URL of the JSON
        service to get the results of the method call, as shown in this
        example from showDetails.jsp:<informalexample>
            <programlisting>function updateReservation(showId, priceCategoryId, quantity) {
    baseUrl = '&lt;c:url value="/bookings/allocate?"/&gt;';
    jQuery.getJSON(baseUrl + "showId=" + showId + "&amp;priceCategoryId=" + priceCategoryId + "&amp;quantity=" + quantity, function (result) {
        if(result == true)
            $("div#priceCategory_" + priceCategoryId).text("Available seats have been allocated.");
        else
            $("div#priceCategory_" + priceCategoryId).text("Insufficient available seats.");
    });
}</programlisting>
          </informalexample></para>

        <para>However, to properly bind the URL used in the jQuery.getJSON()
        call to a Java method, we must use some simple Spring Web annotations.
        In the @RequestMapping annotation, we must add 'produces =
        "application/json" ' to indicate that there will be a JSON service
        corresponding to the URL specified in the same annotation. As well, we
        must annotate the return type of the Java method with the
        @ResponseBody annotation so that Spring will serialize to JSON. The
        updateAllocation() method, from the BookingFormController class, is
        provided as an example of how these annotations should be used
        properly:<informalexample>
            <programlisting>@RequestMapping(value = "/allocate", method=RequestMethod.GET, produces = "application/json")
public @ResponseBody boolean updateAllocation(Long showId, Long priceCategoryId, int quantity) {
    boolean success = false;
    int sectionQuantity = 0;

    Long sectionId = showDao.findPriceCategory(priceCategoryId).getSection().getId();
    int previousQuantity = reservationManager.getBookingState().updateCategoryRequests(priceCategoryId, quantity);

    for(PriceCategoryRequest categoryRequest : reservationManager.getBookingState().getCategoryRequests()) {
        if(categoryRequest.getPriceCategory().getSection().getId().equals(sectionId)) {
            sectionQuantity += categoryRequest.getQuantity();
        }
    }

    success = reservationManager.updateSeatReservation(showId, sectionId, sectionQuantity);

    if(success == false) {
        reservationManager.getBookingState().updateCategoryRequests(priceCategoryId, previousQuantity);
    }

    return success;
}</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>jQuery UI</title>

        <para>An important feature of Ticket Monster is the ability for a user
        to view all the seating sections available at a specific venue, as
        well as the various price categories available in each section. To do
        this, Ticket Monster uses the Accordion feature of jQuery UI.
        Accordion is a standard jQuery widget which, given menu of options,
        displays each option of the menu as its own separate header. Each
        header is also its own dropdown, so that, on click, each menu option's
        content will be displayed as a dropdown. One important feature of
        jQuery Accordion is that only one dropdown can be active at a time;
        thus, clicking a different header will cause the currently displayed
        content to collapse.</para>

        <para>In Ticket Monster, jQuery Accordion is implemented on each
        individual event's view page, i.e. /events/{id} where {id} represents
        the selected event's ID. To implement jQuery Accordion, jQuery UI must
        be included in the src/main/webapp directory of the project, as
        jquery-ui-1.8.14.custom.min.js is in Ticket Monster. Once this is
        included, Accordion only requires some simple HTML, as demonstrated in
        the example below, taken from the jQuery UI website:<informalexample>
            <programlisting>&lt;div id="accordion&gt;
    &lt;h3&gt;&lt;a href="#"&gt;First Header&lt;/a&gt;&lt;/h3&gt;
    &lt;div&gt;First menu option content&lt;/div&gt;
    &lt;h3&gt;&lt;a href="#"&gt;Second Header&lt;/a&gt;&lt;/h3&gt;
    &lt;div&gt;Second menu option content&lt;/div&gt;
&lt;/div&gt;</programlisting>
          </informalexample></para>

        <para>In Ticket Monster, the Accordion section, located in
        eventDetails.jsp, is implemented using a JavaScript, as a JSON service
        is required to populate the Accordion based on the items selected in a
        dropdown menu. JSON services are very important to Ticket Monster for
        a variety of purposes, such as retrieving a show's price categories as
        well as updating or creating seat reservations. </para>
      </section>
    </section>

    <section>
      <title>Enterprise Integration Features</title>

      <para>The Ticket Monster application provides a few other examples of
      integrating Spring and JBoss. Since all the features are Spring-based,
      they have been included as business services of the web application. All
      the definitions for the following examples can be found in the
      src/main/resources/META-INF/spring directory.</para>

      <section>
        <title>Caching</title>

        <para>An important feature of Ticket Monster is the ability for
        multiple users to reserve tickets for the same show at the same time.
        To provide this functionality, the application must keep track of all
        seat blocks that have been reserved and purchased for a given show at
        all times. However, it would be impractical to persist all of this
        data to the Ticket Monster database. Instead, we take advantage of
        another useful feature provided in Spring 3.1 - the Spring Cache
        Abstraction.</para>

        <section>
          <title>CacheManager Configuration</title>

          <para>The Spring Cache Abstraction provides a variety of methods for
          caching, such as annotating entities as @Cacheable and methods as
          @CacheEvict, or dealing directly with a cache object (often either
          an Ehcache or Concurrent Map Cache) retrieved by a CacheManager. In
          the Ticket Monster example, we will inject a CacheManager object,
          declared as a bean in /WEB-INF/ticketmonster-mvc-context.xml; this
          way, we can retrieve the cache of reservations using this
          CacheManager bean. The CacheManager bean definition, as well as the
          cache configuration, are included below:<informalexample>
              <programlisting>&lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt;
    &lt;property name="caches"&gt;
        &lt;set&gt;
            &lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="reservations"/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
    
&lt;bean id="defaultCache" factory-bean="cacheManager" factory-method="getCache"&gt;
    &lt;constructor-arg value="reservations"/&gt;
&lt;/bean&gt;</programlisting>
            </informalexample></para>

          <para>In the above code, the Cache Manager bean is declared as a
          SimpleCacheManager, which is then injected into the various
          implementations of the service layer interfaces using the @Autowired
          annotation. As well, we also declare a default cache, obtained by
          call calling the getCache() method of the SimpleCacheManager with an
          argument of "reservations", which is a ConcurrentMapCache
          object.</para>
        </section>

        <section>
          <title>Cache Lookups</title>

          <para>In order to use caching effectively, we must create a CacheKey
          class, located in org.jboss.spring.ticketmonster.domain, which can
          be uniquely associated with each object stored on the cache. In
          Ticket Monster, we cache objects using a key consisting of a show ID
          and a row ID. The actual object stored on the cache, a
          RowReservation, consists of a CacheKey object for that
          RowReservation as well as a LinkedList of SeatBlock objects,
          representing already reserved or purchased seats by their start and
          end seat. In order for objects to be stored and retrieved from the
          cache properly, we must first override the hash() and equals()
          methods of the CacheKey class, which can be generated automatically
          by JBoss Developer's Studio, as shown here:<informalexample>
              <programlisting>@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((rowId == null) ? 0 : rowId.hashCode());
    result = prime * result + ((showId == null) ? 0 : showId.hashCode());
    return result;
}

@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;

    CacheKey other = (CacheKey) obj;

    if (rowId == null) {
        if (other.rowId != null)
            return false;
    } else if (!rowId.equals(other.rowId))
        return false;
    if (showId == null) {
        if (other.showId != null)
            return false;
    } else if (!showId.equals(other.showId))
        return false;
    return true;
}</programlisting>
            </informalexample></para>

          <para>For examples of using the injected CacheManager to retrieve a
          cache, as well as manipulating the retrieved cache, code
          implementation can be found in both the SimpleReservationManager and
          SimpleAllocationManager implementations of Ticket Monster's service
          layer interfaces.</para>
        </section>
      </section>

      <section>
        <title>Aspects and Cross-Cutting Concerns</title>

        <para>Given the use cases of the Ticket Monster application, it is
        very important for the application to keep record of transaction order
        (such as which seats were reserved when and by whom) as well as
        confirmation of payment. One method of the application maintaining
        this information is to use advice on cross-cutting concerns. In Ticket
        Monster, we implement this advice using Spring Aspect-Oriented
        Programming (Spring AOP), which provides a simple set of AspectJ
        annotations that can be used to advise on the application's business
        logic. To configure Spring AOP, first we must add the following
        definition to the ticketmonster-business-context.xml of the
        META-INF/spring directory:<informalexample>
            <para><programlisting>&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</programlisting></para>
          </informalexample></para>

        <para>This simple XML tag, provided by the Spring aop namespace,
        allows us to use AspectJ annotations to create pointcuts, Below is an
        example of the use of AspectJ annotations to declare pointcuts and
        cross-cutting advice in Ticket Monster's LogInformation
        class:<informalexample>
            <programlisting>@Aspect
public class LogInformation {

protected final Log logger = LogFactory.getLog(getClass()); 

@Pointcut("execution(* org.jboss.spring.ticketmonster.mvc.EventController.displayEvents(javax.servlet.http.HttpServletRequest)) &amp;&amp; args(request)")
public void events(HttpServletRequest request) {
}

    /* Other @Pointcut definitions */

@AfterReturning("events(request)")
public void displayEvents(HttpServletRequest request) {
    String majorString, categoryString, fromDate, untilDate;

    majorString = request.getParameter("major");
    categoryString = request.getParameter("category");
    fromDate = request.getParameter("from");
    untilDate = request.getParameter("until");

    if(majorString != null) {
        logger.info("Returning event information for all events with the major field marked as: " + majorString + ".");
        return;
    }

    else if(categoryString != null) {
        logger.info("Returning event information for all events in the category: ");
        int categoryId = categoryString.charAt(0) - '0';
        switch(categoryId) {
            case 1:
            logger.info("Concerts.");
            return;
            case 2:
            logger.info("Theatre.");
            return;
            case 3:
            logger.info("Musicals.");
            return;
            case 4:
            logger.info("Sports");
            return;
            case 5:
            logger.info("Comedy.");
            return;
            default:
            logger.info("Invalid Category");
            return;
        }
    }

    else if(fromDate != null &amp;&amp; untilDate != null) {
        logger.info("Returning event information for all events starting on or after: " + fromDate + " and ending on or before " + untilDate  + "."); 
    }

    else {
        logger.info("Returning event information for all events currently in the TicketMonster database.");
    }

    return;
}

    /* Other cross-cutting concern advice */

}</programlisting>
          </informalexample></para>

        <para>In the above example, the @Aspect annotation indicates to the
        application that the LogInformation class should be scanned for
        pointcuts and cross-cutting advice. The @Pointcut annotation defines a
        pointcut, which specifies the joinpoint when cross-cutting advice will
        be applied, such as the execution of a particular method or within a
        certain type, to provide two examples. In the case of an execution
        pointcut, where the joinpoint occurs on the execution of a method, we
        use annotations such as @Before, @AfterReturning, @AfterThrowing, or
        @After, to indicate whether the joinpoint will occur before execution,
        after successful execution, after an exception is thrown, etc. Note
        that, in the above example, to pass a parameter to advice via the
        pointcut, we must add the parameter type to the execution designator
        and an args() designator, specifying the parameter names to be passed.
        As well, it should be mentioned that, while in this example, we only
        use cross-cutting advice to log information, aspect-oriented
        programming can be used for more complex uses, e.g. calls to methods
        upon successful completion of each transaction.</para>
      </section>

      <section>
        <title>JBoss-Authenticated Security</title>

        <para>To ensure that only authenticated users are able to make
        reservations and pay for previously reserved seats, we use Spring
        Security 3.1.0.RC2 to restrict access to certain pages of the Ticket
        Monster example. Access to the reservations and checkout page (i.e.
        all URLs of '/booking**') is restricted, as described in
        META-INF/spring/ticketmonster-security-context.xml, To enable Spring
        Security, we must first add this ticketmonster-security-context.xml
        file to the contextConfigLocation, specified as a
        &lt;context-param&gt; elementin web.xml. </para>

        <para>One level of security is added by enabling Spring Security
        annotations. Using these annotations, we can ensure that certain
        methods can only be called by users with the specified credentials.
        This is accomplished by adding the following XML code to the
        ticketmonster-security-context.xml:<informalexample>
            <para><programlisting>&lt;global-method-security pre-post-annotations="enabled"/&gt;</programlisting></para>
          </informalexample></para>

        <para>With these annotations enabled, we can then annotate methods,
        such as the methods of the ReservationManager interface, as
        @PreAuthorize("hasRole('ROLE_USER')"). By including this annotation,
        only those with the role of User, in this case those with an account
        in the Ticket Monster database, can call methods of the
        ReservationManager interface.</para>

        <para>To add another layer of security to the Ticket Monster example,
        we restrict the access to certain URLs within the Ticket Monster
        application. This is accomplished by adding intercept-url definitions
        to the ticketmonster-security-context.xml file:<informalexample>
            <programlisting>&lt;http pattern="/static/**" security="none" /&gt;

&lt;http use-expressions="true"&gt;
    &lt;intercept-url pattern="/bookings/**" access="hasRole('ROLE_USER')"/&gt;
    &lt;intercept-url pattern="/events**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/events/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/venues**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/venues/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/shows/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/categories**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/index.jsp" access="permitAll"/&gt;
    &lt;intercept-url pattern="/**" access="denyAll"/&gt;
    &lt;form-login/&gt;
    &lt;logout logout-success-url="/"/&gt;
&lt;/http&gt;</programlisting>
          </informalexample></para>

        <para>There are a few important points to note from the above section
        of code:<itemizedlist>
            <listitem>
              <para>It is essential to make sure there is no security on the
              '/static/**' URLs, otherwise no images, CSS files, etc. will be
              accessible to non-authenticated users</para>
            </listitem>

            <listitem>
              <para>An &lt;intercept-url&gt; tag should be included to cover
              each web view, even if the access is 'permitAll', though access
              can also be 'denyAll', 'hasRole('ROLE_USER'),
              'hasRole('ROLE_SUPERVISOR'), or custom-defined roles</para>
            </listitem>

            <listitem>
              <para>If JSON services are used, the correct access must be
              given to the URL of the JSON call</para>
            </listitem>

            <listitem>
              <para>The &lt;form-login/&gt; will ensure that Spring Security
              prompts for authentication before displaying a page which the
              user does not currently have authorization to view</para>
            </listitem>
          </itemizedlist></para>

        <para>Finally, we must tell Ticket Monster how to verify a user's
        credentials when they attempt to log in. For security purposes, Ticket
        Monster stores passwords as salted one-way hashes, created by Spring
        Security's StandardPasswordEncoder. Once we have encoded each
        password, we can either store the hashed passwords in the
        ticketmonster-security-context.xml file itself or in the Ticket
        Monster database, querying the database to verify credentials. This
        implementation uses the latter implementation of password encryption,
        as demonstrated by code below from the security context and database
        initialization files.<informalexample>
            <programlisting>// From ticketmonster-security-context.xml

&lt;beans:bean id="encoder" class="org.springframework.security.crypto.password.StandardPasswordEncoder"/&gt;

&lt;authentication-manager&gt;
    &lt;authentication-provider&gt;
    &lt;password-encoder ref="encoder"/&gt;
    &lt;jdbc-user-service data-source-ref="dataSource" 
        users-by-username-query="select username, password, enabled from User where username = ?"
        authorities-by-username-query="select username, 'ROLE_USER' from User where username = ?"/&gt;
    &lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;

// From import.sql

insert into User (id, username, password, enabled, firstName, lastName) values (1, 'sbryzak', '12bfe8fb06f06eedec67fb43ef6ab8c850a577db73e758c40b5fceff86d9e214c36612e430b23a5e', 'true', 'Shane', 'Bryzak');
insert into User (id, username, password, enabled, firstName, lastName) values (2, 'mbg', 'eefcbef8c277b21f88d7fa36dc7e33fbf243587de1cac2dcc4edcaa717796e7326980ad18161bd4f', 'true', 'Marius', 'Bogoevici');
insert into User (id, username, password, enabled, firstName, lastName) values (3, 'rbradley', 'e5b60370d330faeddb4aef7b34ef2877cebcfaad814e62da7e9d3abe8b3be6146410572b2f21047c', 'true', 'Ryan', 'Bradley');</programlisting>
          </informalexample></para>

        <para>For those interested in adding their own User to the database,
        the id, username, firstName, and lastName fields are self-explanatory.
        The enabled field should indicate whether the added user should have
        ROLE_USER priveleges. As well, instructions to encode passwords can be
        found in the Spring Security tutorial at
        http://static.springsource.org/spring-security/site/tutorial.html.</para>
      </section>
    </section>
  </chapter>
</book>
