<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <bookinfo>
    <title>Snowdrop Ticket Monster Example Application</title>

    <subtitle>Integrating Spring with the JBoss Enterprise Application
    Platforms</subtitle>

    <productname>JBoss Web Framework Kit</productname>

    <productnumber>2.0</productnumber>

    <edition>1.0</edition>

    <pubsnumber>0</pubsnumber>

    <abstract>
      <para>This book provides a walkthrough for the Snowdrop Ticket Monster
      example application. It illustrates several use cases of the JBoss
      Enterprise Application Platform with the Spring Framework.</para>
    </abstract>

    <corpauthor>JBoss by Red Hat</corpauthor>

    <authorgroup>
      <author>
        <firstname>Ryan</firstname>

        <surname>Bradley</surname>

        <affiliation>
          <orgname>JBoss by Red Hat</orgname>
        </affiliation>

        <email>rbradley@redhat.com</email>
      </author>

      <author>
        <firstname>Marius</firstname>

        <surname>Bogoevici</surname>

        <affiliation>
          <orgname>JBoss by Red Hat</orgname>
        </affiliation>

        <email>mariusb@redhat.com</email>
      </author>
    </authorgroup>

    <pubdate>October 7, 2011</pubdate>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <section>
      <title>Feedback</title>

      <para>If you find a typographical error in this manual, or if you have
      thought of a way to make this manual better, we would love to hear from
      you! Please submit a report in JIRA: <ulink
      url="http://jira.jboss.org/">http://jira.jboss.org/</ulink> against the
      product <application>Snowdrop</application> and component
      <emphasis>Examples</emphasis>.</para>

      <para>When submitting a bug report, be sure to mention the manual's
      identifier: Snowdrop <citetitle>Ticket Monster
      Example</citetitle>.</para>

      <para>If you have a suggestion for improving the documentation, try to
      be as specific as possible when describing it. If you have found an
      error, please include the section number and some of the surrounding
      text so we can find it easily.</para>
    </section>
  </preface>

  <chapter>
    <title>Introduction</title>

    <para>The Ticket Monster application provides a real world-inspired
    example of integrating Spring with the JBoss Entprise Platforms. It is a
    web application, which illustrates several use cases through various
    combinations of components and technologies. It also illustrates how to
    use the Snowdrop libraries to provide JBoss-specific features, such as
    creating a standalone deployment of an
    <classname>ApplicationContext</classname> and injecting beans from that
    application context into non-Spring components like Enterprise Java Beans
    (EJB).</para>

    <para>This book aims to illustrate the mechanics of using Spring with
    different Java EE 6 components in the specific context of the JBoss
    Enterprise Platforms, and to recommend methods of achieving certain
    integration goals.</para>

    <para>The Ticket Monster example is not intended as a guide to creating a
    domain model. Detailing the various layers of application and UI design is
    outside the scope of this document. As such, the example application has
    been designed to illustrate integration use cases, rather than to
    demonstrate a domain model that strictly follows principles of
    object-oriented and domain-driven design.</para>

    <section>
      <title>Prerequisites</title>

      <para>Deployment of the Ticket Monster application requires the
      following:</para>

      <itemizedlist>
        <listitem>
          <para>Java 6 JDK</para>
        </listitem>

        <listitem>
          <para>JBoss Application Server 7.0.0.Final or later</para>
        </listitem>

        <listitem>
          <para>Maven 2.0.9 or later, with appropriate repositories</para>
        </listitem>
      </itemizedlist>

      <simplesect>
        <title>Setting Up Maven Repositories</title>

        <para>The Maven project setup does not make any assumptions where the
        artifacts used in the project are coming from (which repository), as
        users may have different settings for their Maven repositories (direct
        access to community repositories, proxies, enterprise repository with
        approved artifacts). Therefore, the setup of the repositories is left
        to the user of the application.</para>

        <para>In the most simple case, this example can be built out of the
        box if the settings.xml file for the local Maven installation enables
        the repositories from Maven Central and JBoss Releases. Instructions
        for setting up the latter can be found at:
        http://community.jboss.org/wiki/MavenGettingStarted-Users.</para>

        <para>The pom.xml can be modified to include references to other
        repositories, or equivalent artifact versions (if the build
        environment uses an enterprise-wide repository in which the artifacts
        have different version numbers).</para>
      </simplesect>
    </section>

    <section>
      <title>How to Build and Run Ticket Monster</title>

      <para>This document will provide a detailed account of the application
      and its use cases. However, often, it is easier to just run the
      application to answer your questions.</para>

      <itemizedlist>
        <listitem>
          <para>Building the application</para>
        </listitem>

        <listitem>
          <para>Preparing JBoss</para>
        </listitem>

        <listitem>
          <para>Deploying the application</para>
        </listitem>

        <listitem>
          <para>Starting the application server</para>
        </listitem>
      </itemizedlist>

      <para>Below, you will find instructions on how to perform each of these
      steps.</para>

      <simplesect>
        <title>Building the application</title>

        <para>In this step, we build the application. Since Ticket Monster
        uses Maven, so it can be built from the command line by simple
        running:</para>

        <informalexample>
          <programlisting>mvn clean package</programlisting>

          <para>This produces a WAR file, named TicketMonster.war, under
          TicketMonster/target. The application can then be deployed by moving
          this .war file to ${JBOSS_AS_7_HOME}/standalone/deployments and then
          executing the standalone.sh script, located in
          ${JBOSS_AS_7_HOME}/bin directory. The database will be initialized
          during this process by the SQL script, import.sql, included in the
          src/main/resources directory of the Ticket Monster project. Ticket
          Monster uses Spring 3.1.0.M2 and Spring Security 3.1.0.RC2.</para>
        </informalexample>
      </simplesect>

      <simplesect>
        <title>Preparing JBoss</title>

        <para>In addition to building the application, the JBoss Application
        Server must also be properly configured before deploying the
        application. Specifically, this involves creating a datasource
        definition within the configuration of the JBoss Application Server.
        To accomplish this, open the standalone.xml file, located in
        ${JBOSS_AS_7_HOME}/standalone/configuration. Next, under the
        &lt;datasources&gt; element, contained within a subsystem of the
        server, add the following data source definition:<informalexample>
            <para><programlisting>&lt;datasource jndi-name="java:jboss/datasources/TicketMonsterDS" pool-name="TicketMonsterDS"
   enabled="true" jta="true" use-java-context="true" use-ccm="true"&gt;
   &lt;connection-url&gt;
      jdbc:h2:mem:test;DB_CLOSE_DELAY=-1
   &lt;/connection-url&gt;
   &lt;driver&gt;
      h2
   &lt;/driver&gt;
   &lt;pool&gt;
      &lt;prefill&gt;
          false
      &lt;/prefill&gt;
      &lt;use-strict-min&gt;
          false
      &lt;/use-strict-min&gt;
      &lt;flush-strategy&gt;
          FailingConnectionOnly
      &lt;/flush-strategy&gt;
   &lt;/pool&gt;
   &lt;security&gt;
      &lt;user-name&gt;
          sa
      &lt;/user-name&gt;
      &lt;password&gt;
          sa
      &lt;/password&gt;
   &lt;/security&gt;
   &lt;validation&gt;
      &lt;validate-on-match&gt;
          false
      &lt;/validate-on-match&gt;
      &lt;background-validation&gt;
          false
      &lt;/background-validation&gt;
      &lt;useFastFail&gt;
          false
      &lt;/useFastFail&gt;
   &lt;/validation&gt;
&lt;/datasource&gt;</programlisting>This definition is necessary for the
            application to be create an in-memory database for the
            application, which can be retrieved via a JNDI look-up.</para>
          </informalexample></para>
      </simplesect>

      <simplesect>
        <title>Deploying the Application</title>

        <para>Copy the WAR file produced by the build to deploy folder of the
        JBoss Application Server.</para>

        <para>The WAR file is located in TicketMonster/target, and should be
        copied to ${JBOSS_AS_7_HOME}/standalone/deployments.</para>
      </simplesect>
    </section>

    <section>
      <title>Ticket Monster and JBoss Developer's Studio</title>

      <para>The easiest way to gain a deeper understanding of the Ticket
      Monster web application is to examine the source code directly. This
      guide will instruct you how to import the application into JBoss
      Developer's Studio (JBDS).</para>

      <para>Ticket Monster is a Maven-based application; thus, to navigate its
      structure in JBoss Developer's Studio, you must create an Eclipse
      project for it. This can be done using the Maven Eclipse
      plugin:<informalexample>
          <programlisting>mvn eclipse:eclipse -Dwtpversion=2.0</programlisting>

          <para>Alternatively, the m2e Maven Integration for Eclipse plugin
          can be used to import the project into JBoss Developer's
          Studio.</para>
        </informalexample></para>

      <simplesect>
        <title>Importing Ticket Monster into JBDS</title>

        <para>Ticket Monster is a Maven-based project, so you can import it
        into JBDS if you have the m2eclipse Maven integration plugin
        installed, including the m2eclipse WTP extension. Installation can be
        found at http://download.eclipse.org/technology/m2e/releases/.</para>

        <para>For importing the project, go to
        'Import...'-&gt;'Maven'-&gt;'Existing Maven Projects' and select the
        top directory of the Ticket Monster example. You will be shown the
        project's pom.xml file.</para>
      </simplesect>
    </section>
  </chapter>

  <chapter>
    <title>Understanding the Application Structure</title>

    <para>This chapter will describe the business use cases covered by the
    Ticket Monster application.</para>

    <section>
      <title>Application Structure and Use Cases</title>

      <para>The Ticket Monster application is an example of an online ticket
      reseller, such as Ticketmaster. Users of Ticket Monster should be able
      to retrieve information about events from the website:<itemizedlist>
          <listitem>
            <para>View all events in the Ticket Monster database</para>
          </listitem>

          <listitem>
            <para>Query the database of events based on start date, end date,
            event category, whether it is major or not, etc.</para>
          </listitem>

          <listitem>
            <para>Retrieve event specific information such as event
            description, host venues, venue information, seating sections and
            prices, and show times</para>
          </listitem>

          <listitem>
            <para>View all venues in the Ticket Monster database</para>
          </listitem>

          <listitem>
            <para>Display all events being held at a specific venue, and
            navigate to individual event pages</para>
          </listitem>
        </itemizedlist></para>

      <para>As well, users need to reserve and purchase tickets for shows,
      i.e. occurrences of an event at a specific venue. To accomplish this,
      the application has the following requirements:<itemizedlist>
          <listitem>
            <para>Check a user's security credentials using Spring
            Security</para>
          </listitem>

          <listitem>
            <para>Reserve seats from specific sections to the current user for
            specific shows</para>
          </listitem>

          <listitem>
            <para>Manage a cache of currently reserved or purchased seats for
            shows in the Ticket Monster database</para>
          </listitem>

          <listitem>
            <para>Maintain a session-scoped object of the current user's
            reservations, allocations (i.e. purchased seats), and price of
            tickets in the user's shopping cart</para>
          </listitem>

          <listitem>
            <para>Persist purchased reservations to the database when a user
            finishes allocating seats or 'checks out'</para>
          </listitem>

          <listitem>
            <para>Display a list of all purchased seat blocks and the total
            price on the check out page</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </chapter>

  <chapter>
    <title>Using JBoss and Spring Together</title>

    <para>This chapter will describe the various Spring and JBoss integration
    use cases covered by the application and how are they implemented in
    Ticket Monster.</para>

    <section>
      <title>Integration of JBoss and Spring Use Cases</title>

      <para>The Ticket Monster application covers a number of JBoss and Spring
      integration use cases. The scenarios selected for this example are
      focusing on using the Java EE 6 services provided by the JBoss
      Application Server in Spring applications. Below, the various use cases
      are grouped into categories:</para>

      <table>
        <title>Overview of Spring/JBoss Integration Use Cases</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Category</entry>

              <entry align="center">Use case</entry>

              <entry align="center">How does this involve JBoss AS</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Persistence</entry>

              <entry>Spring/JPA integration</entry>

              <entry>The Persistence Unit is deployed by JBoss and retrieved
              from JNDI to be injected into Spring beans. PersistenceContext
              is shared with surrounding EJBs (if any).</entry>
            </row>

            <row>
              <entry>Testing</entry>

              <entry>Unit-testing components that have managed infrastructure
              dependencies</entry>

              <entry>The DataSource and EntityManager are managed by JBoss and
              acquired from JNDI by Spring when the application is running. In
              the case of JBoss, developers can test their code in isolation
              using Spring-specific replacements that 'simulate' the JBoss
              environment.</entry>
            </row>

            <row>
              <entry>Business Logic</entry>

              <entry>Spring-based service beans</entry>

              <entry>The business services are Spring-managed and wrapped into
              transactions managed by Spring's interceptors. The
              TransactionManager in use is the JTATransactionManager using
              JBoss Transactions provided in JBoss AS.</entry>
            </row>

            <row>
              <entry>User Interface</entry>

              <entry>Spring MVC and EJB integration</entry>

              <entry>The application uses Spring MVC and the business logic is
              implemented using JBoss-deployed EJBs, which are injected into
              the Spring controllers</entry>
            </row>

            <row>
              <entry>Aspect-Oriented Programming</entry>

              <entry>Spring-based weaving of POJO aspects</entry>

              <entry>This use case does not have any JBoss AS-specific
              functionality.</entry>
            </row>

            <row>
              <entry>Security</entry>

              <entry>Application-server pre-authentication</entry>

              <entry>The application uses Spring Security for authorizing
              access to resources. Authentication is provided by the
              application server.</entry>
            </row>

            <row>
              <entry>Caching</entry>

              <entry>Spring-based management of cache</entry>

              <entry>The application uses the Spring Simple Cache Manager to
              retrieve a Concurrent Map cache, which tracks seat allocations,
              for future reservations.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Domain Model</title>

      <para>The package org.jboss.spring.ticketmonster.domain does not include
      any classes which interact directly with Spring. However, the domain
      package is important as it contains definitions for the application's
      entities.</para>

      <figure>
        <title>Ticket Monster Entities</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="???" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>A more detailed description of many of the entities is not
      provided, as the only other members which they have are
      primitives.</para>
    </section>

    <section>
      <title>Persistence Implementation - JPA</title>

      <para>The application's persistence strategy is implemented using the
      Java Persistence API (JPA). Persistence-related classes are defined in
      the org.jboss.spring.ticketmonster.repo package. This package includes
      implementations of repository interfaces for database access, and Spring
      context definition fragments that can be re-used elsewhere in the
      application. This section describes how JPA was used to implement
      persistence in the Ticket Monster example, as well as how the various
      repository implementations can be unit tested with the JPA
      implementation.</para>

      <section>
        <title>JPA Implementation</title>

        <para>JPA provides a parametrized superclass that is Spring-agnostic
        as well (except for the usage of the Spring @Autowired annotation -
        which can be replaced by a simple setter if any reference to Spring
        needs to be removed). For database access, the JPA implementation uses
        the JPA EntityManager (javax.persistence.EntityManager) interface to
        query the database and retrieve results. The JPA Persistence Unit (and
        subsequent EntityManager) are created by the JBoss Application Server,
        not by Spring (though the EntityManager is injected by Spring, it is
        acquired from JNDI). The Spring application context configuration
        fragments can be found in the following locations:</para>

        <itemizedlist>
          <listitem>
            <para>src/main/resources/META-INF/spring/ticketmonster-business-context.xml
            - contains Spring bean definitions for repository of
            implementations, assumes that the EntityManager bean definition is
            contained in the infrastructure.xml file</para>
          </listitem>

          <listitem>
            <para>src/main/resources/META-INF/spring/infrastructure.xml -
            contains definitions for infrastructure-related Spring beans, such
            as the data source, EntityManager, and JTA transaction
            manager</para>
          </listitem>

          <listitem>
            <para>src/main/resources/META-INF/persistence.xml - contains the
            persistence unit definition for ticketmonsterPU</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>JUnit Testing of the Repositories</title>

        <para>With the infrastructure of the application coupled so tightly to
        the application server, we are presented with the issue of thoroughly
        unit testing and debugging the repositories in isolation, before they
        are fully integrated with the rest of the application.</para>

        <para>If at deployment, we use services provided by the JBoss
        Application Server, such as the data source, EntityManager, and
        transaction manager, then for the unit tests, we will use an embedded
        data source, Spring's ability to create a LocalEntityManager, and its
        local transaction manager capabilities.</para>

        <para>For this, we use the spring-test-infrastructure module, a
        test-scoped dependency in the project's pom. This module contains the
        modules used for setting up an embedded database (producing a
        DataSource that can be injected into the
        LocalContainerEntityManagerFactoryBean). The localized EntityManager
        and transaction manager definitions is located in the
        src/test/resources/test-context.xml file, while other definitions
        related to the JUnit test context can be found in the
        src/test/resources/META-INF directory.</para>

        <para>The JUnit tests are located in the
        org.jboss.spring.ticketmonster.test package of the src/test/java
        directory. The unit tests will use the test context and local
        infrastructure XML files as in the following example:<informalexample>
            <programlisting>@ContextConfiguration(locations = {"classpath:test-context.xml",
"classpath:/META-INF/spring/ticketmonster-business-context.xml",
"classpath:/META-INF/test-bookingState.xml"})
@RunWith(SpringJUnit4ClassRunner.class)
@TransactionConfiguration(defaultRollback=true)
public class TestTicketMonsterRepository() {
/* JUnit tests */
}</programlisting>

            <para>This configuration reuses the 'application-specific' context
            configuration fragment, i.e. the repository bean definitions, as
            well as two test-specific (or otherwise said local) context
            configuration fragments in order to create a Spring context in
            isolation. Thus, the functionality provided by the repositories
            can be tested outside the running application.</para>
          </informalexample></para>
      </section>
    </section>

    <section>
      <title>Service Layer</title>

      <para>On top of the domain and persistence layer sits the service layer
      of the application. Its role is to co-ordinate the domain objects and
      repositories in order to perform higher level operations. This is also
      the layer which provides transaction demarcation, using Spring's
      @Transactional annotation. One consideration for which transaction
      demarcation should be done at service level is to ensure that the
      changes made by service operations are atomic. Otherwise, concurrent
      operations may leave the application data in an inconsistent state.
      Demarcating transactions at the repository/DAO level should be done
      carefully, taking into consideration that multiple repository/DAO
      invocations that are not surrounded by a wrapping transactions will
      execute in separate transactional contexts.</para>

      <para>In the Ticket Monster application, the service layer consists of
      the ReservationManager and AllocationManager interfaces. These
      interfaces are implemented using Spring; both the interfaces themselves
      and the classes implementing them can be found in the
      org.jboss.spring.ticketmonster.service package.</para>

      <para>This Spring-based service layer exposes a number of service beans
      that can be consumed by the UI, which are injected with the beans
      defined in the persistence layer, in
      src/main/ticketmonster-business-context.xml, much like the repositories.
      Given how this is a fairly straightforward Spring configuration, we will
      not insist much on this topic, except for outlining that this is the
      level where transaction demarcation is provided by the use of the
      appropriate Spring annotations. Spring Security is also used to ensure
      that only users with the appropriate authorization can make changes to
      the cache and database. For example, users who are just browsing Ticket
      Monster for event information should not be able to reserve seats, thus
      allocating them in the cache, unless they have logged in to an account
      with Ticket Monster.</para>
    </section>

    <section>
      <title>Presentation Layer</title>

      <para>The Ticket Monster web application illustrates how we can
      integrate Spring and Java EE technologies in the presentation layer, in
      this case using Spring MVC to create the web controllers and JSF to
      handle display of the various pages:</para>

      <section>
        <title>Configuration of Spring MVC and Apache Tiles</title>

        <para>To integrate the UI and Spring MVC, we use the Spring provided
        DispatcherServlet, defined in src/main/webapp/WEB-INF/web.xml as shown
        in the snippet of code below:<informalexample>
            <programlisting>&lt;servlet&gt;
    &lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/spring-webflow-config.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;


&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/flow/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
          </informalexample></para>

        <para>The Spring business application is bootstrapped by the
        ContextLoaderListener, a Spring web class, defined in
        /WEB-INF/web.xml. The Spring configuration file in use is
        /WEB-INF/ticketmonster-mvc-context.xml, which defines a number of
        Spring beans that are used directly in the web tier by the JSP pages.
        These beans include a ResourceBundleMessageSource, so that messaging
        macros can be used in JSP, and a ContentNegotiatingViewResolver.
        Further, web.xml includes several bean definitions required in order
        to properly configure Apache Tiles; these include a TilesViewResolver
        to map view names to Tiles Definitions and a TilesConfigurer to
        initialize the Tiles CompositeView system. The bean definitions are
        included below:<informalexample>
            <programlisting>&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.tiles2.TilesViewResolver"&gt;
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.tiles2.TilesView"/&gt;
    &lt;property name="order" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles2.TilesConfigurer"&gt;
    &lt;property name="definitions"&gt;
        &lt;list&gt;
            &lt;value&gt;/WEB-INF/**/layouts.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/**/views.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>Spring MVC</title>

        <para>Ticket Monster provides an example of how Spring can be
        integrated with the JBoss Application Server, using Spring for the web
        tier and presentation layer of the application. This is accomplished
        by using the Spring Web MVC framework. Spring MVC allows us to easily
        use annotations to denote controllers, map controllers to various
        views, create GET and POST methods, to name just a few functions of
        Spring MVC. The Spring MVC beans are defined in the
        /WEB-INF/ticketmonster-mvc-context.xml file, referenced by the
        DispatcherServlet referenced in the previous section. First, we must
        add some XML elements to ticketmonster-mvc-context.xml in order to
        take full advantage of Spring MVC, as shown below:<informalexample>
            <programlisting>&lt;context:component-scan base-package="org.jboss.spring.ticketmonster.mvc"/&gt;

&lt;mvc:annotation-driven /&gt;

&lt;mvc:resources mapping="/static/**" location="/" /&gt;

&lt;mvc:default-servlet-handler/&gt;</programlisting>
          </informalexample></para>

        <para>The above elements are necessary for the following
        reasons:<itemizedlist>
            <listitem>
              <para>&lt;mvc:annotation-driven /&gt; advises that the
              application to search for Spring MVC annotations to indicate
              controllers, request mappings, etc.</para>
            </listitem>

            <listitem>
              <para>&lt;context:component-scan
              base-package="org.jboss.spring.ticketmonster.mvc"/&gt; indicates
              where to scan for Spring MVC annotations (in this case the
              org.jboss.spring.ticketmonster.mvc package)</para>
            </listitem>

            <listitem>
              <para>&lt;mvc:resources mapping="/static/**" location="/" /&gt;
              maps static resources, such as CSS files, images, etc. to the
              fake URL '/static/**', so that the servlet is mapped to
              '/'</para>
            </listitem>

            <listitem>
              <para>&lt;mvc:default-servlet-handler/&gt; allows the
              DispatcherServlet to be mapped to '/', overriding the
              container's default servlet</para>
            </listitem>
          </itemizedlist></para>

        <para>The Ticket Monster application uses Spring 3 MVC
        annotation-based configuration, exemplified below via a skeleton
        version of the BookingFormController:</para>

        <informalexample>
          <programlisting>@Controller
@RequestMapping("/bookings")
public class BookingFormController {

/* Injection of repositories and service managers */

    @RequestMapping(value = "/{id}", method=RequestMethod.GET)
    public String viewShow(@PathVariable("id") Long id, Model model) {}

    @RequestMapping(value="/checkout", method=RequestMethod.POST)
    public String onSubmit(Model model) {}

    @RequestMapping(value = "/allocate", method=RequestMethod.GET, produces = "application/json")
    public @ResponseBody boolean updateAllocation(Long showId, Long priceCategoryId, int quantity) {}
}</programlisting>
        </informalexample>

        <para>The above skeleton of code demonstrates the use of some very
        important annotations when using Spring MVC to handle the web tier of
        an application. These annotations include:<itemizedlist>
            <listitem>
              <para>@Controller - designates the annotated class as a Spring
              MVC controller</para>
            </listitem>

            <listitem>
              <para>@RequestMapping - maps the specific class and/or function
              to a URL, relative to the servlet path</para>
            </listitem>

            <listitem>
              <para>RequestMethod - though not an annotation per se, it is
              still important as it designates the specific method as a GET,
              POST, etc.</para>
            </listitem>

            <listitem>
              <para>@PathVariable - binds an element from a specified URL path
              to a variable, e.g. bookings/{id} binds the value of id to a
              variable for a GET method</para>
            </listitem>
          </itemizedlist></para>

        <para>Note that, although not used in this example, method parameters
        can also be specified via the URL using the @RequestParameter
        annotation. For example, in the EventController class, the getEvents()
        method first checks if any parameters were specified regarding which
        events to retrieve. In that example, the user can specify parameters
        such as 'major' by navigating to URL like '/events?major=true' and the
        getEvents() method would retrieve all events that were marked as
        major.</para>
      </section>

      <section>
        <title>jQuery and JSON</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>Enterprise Integration Features</title>

      <para>Apart from the Spring/JSF/EJB integration, which you have seen in
      the previous sections, the Sportsclub application suite provides a few
      other examples of integrating Spring and JBoss. Since all the features
      are Spring-based, they have been included as business services of the
      Invoicing web application. All the definitions for the following
      examples can be found in the /WEB-INF/spring-business-context.xml file
      defined in the spring-invoicing-webmvc module.</para>

      <section>
        <title>Aspects and Cross-Cutting Concerns</title>

        <para>Payments must be audited. Besides keeping a record of payments
        associated with an account, we may want to set up an auditing service
        that will audit every attempt of making a payment. In the simplest
        case we can just log that information, although in a real life
        scenario things may be more sophisticated. In order to do so, we set
        up a PaymentAuditor aspect that intercepts every call made to the
        PaymentProcessor.</para>

        <para>The aspect is a simple POJO:</para>

        <para><informalexample>
            <para><programlisting>public class PaymentAuditor
{
   /* code ommitted */

   public void auditPayment(Long accountId, BigDecimal amount)
   {
     System.out.println("AUDIT ENABLED! A payment has been made to account "
                          + accountId + " for the amount of " + amount);
   }
}</programlisting></para>
          </informalexample>The aspect is applied through the following
        definitions:</para>

        <informalexample>
          <para><programlisting>   &lt;aop:config&gt;
       &lt;aop:aspect ref="paymentAuditor"&gt;
           &lt;aop:pointcut id="processingPayment" 
               expression="execution(* *..PaymentProcessor+.*(..)) &amp;amp;&amp;amp; args(accountId, amount)"/&gt;
           &lt;aop:before arg-names="accountId, amount" pointcut-ref="processingPayment" method="auditPayment"/&gt; 
       &lt;/aop:aspect&gt;
   &lt;/aop:config&gt;

   &lt;bean id="paymentAuditor" class="org.jboss.snowdrop.samples.sportsclub.audit.PaymentAuditor"/&gt; 

</programlisting>As you can see, the aspect is defined as a bean and applied
          as an aspect through the Spring aop namespace. The pointcut
          definition is an AspectJ expression.</para>
        </informalexample>
      </section>

      <section>
        <title>Secure invoicing: JBoss-preauthenticated security</title>

        <para>The invoicing module also illustrates the usage of JBoss-based
        preauthentication and interaction with Spring Security. Access to the
        invoicing module is secured using the Java EE security mechanisms, as
        described web.xml:</para>

        <para><informalexample>
            <para><programlisting>&lt;security-constraint&gt;
          &lt;web-resource-collection&gt;
               &lt;web-resource-name&gt;All resources&lt;/web-resource-name&gt;
               &lt;description&gt;Protects all resources&lt;/description&gt;
               &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
          &lt;/web-resource-collection&gt;
          &lt;auth-constraint&gt;
               &lt;role-name&gt;*&lt;/role-name&gt;
          &lt;/auth-constraint&gt;
     &lt;/security-constraint&gt;
    &lt;login-config&gt;
        &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
        &lt;realm-name&gt;sportsclub-invoicing&lt;/realm-name&gt;
    &lt;/login-config&gt;
    &lt;security-role&gt;
        &lt;role-name&gt;ADMINISTRATOR&lt;/role-name&gt;
    &lt;/security-role&gt;
    &lt;security-role&gt;
        &lt;role-name&gt;EMPLOYEE&lt;/role-name&gt;
    &lt;/security-role&gt;</programlisting></para>

            <para>In this scenario, the security domain is set up externaly
            (for example for multiple applications) and linked to the web
            application by the definition in jboss-web.xml</para>

            <informalexample>
              <para></para>
            </informalexample>

            <programlisting>&lt;jboss-web&gt;
     &lt;security-domain&gt;java:/jaas/employees&lt;/security-domain&gt;
&lt;/jboss-web&gt;</programlisting>

            <para>In the scenario implemented by this application, the concept
            of an 'employee who can access the application' is external to the
            application itself (perhaps multiple applications can use the same
            security domain) and defined globally in the
            security-jboss-beans.xml file (deployed in the server setup
            phase).</para>

            <informalexample>
              <para></para>
            </informalexample>

            <programlisting>&lt;application-policy xmlns="urn:jboss:security-beans:1.0" name="employees"&gt;
        &lt;authentication&gt;
            &lt;login-module code="org.jboss.security.auth.spi.DatabaseServerLoginModule"
                          flag="required"&gt;
                &lt;module-option name="unauthenticatedIdentity"&gt;guest&lt;/module-option&gt;
                &lt;module-option name="dsJndiName"&gt;java:/SportsClubDS&lt;/module-option&gt;
                &lt;module-option name="principalsQuery"&gt;
                    select passwd from USERS where username=?
                &lt;/module-option&gt;
                &lt;module-option name="rolesQuery"&gt;
                    select userRoles,'Roles' from ROLES where username=?
                &lt;/module-option&gt;
            &lt;/login-module&gt;
        &lt;/authentication&gt;
    &lt;/application-policy&gt;</programlisting>

            <para>Essentially, the login will be performed based on the data
            contained in the USERS and USERROLES tables defined up during the
            process of setting up the Sportsclub DS datasource (however, it is
            not the application that accesses the database directly, but the
            JaaS login module):</para>

            <informalexample>
              <para></para>
            </informalexample>

            <programlisting>INSERT INTO USERS VALUES ('admin','adminPass')
INSERT INTO USERS VALUES ('employee','employeePass')
INSERT INTO ROLES VALUES ('admin','ADMINISTRATOR')
INSERT INTO ROLES VALUES ('admin','EMPLOYEE')
INSERT INTO ROLES VALUES ('employee','EMPLOYEE')
</programlisting>

            <para>The two users admin and employee are used to illustrate the
            different authorization levels in the application. The application
            uses Spring Security for authorizing access to the invoicing
            application's components (web pages and methods) as described in
            /WEB-INF/spring-security-context.xml. Because the application can
            be built either with Spring 2.5 and Spring 3, it will also use
            different Spring Security versions. Because of package name
            changes from Spring Security 2 to Spring Security 3, the</para>

            <para>Of specific interest to our application is the
            filterSecurityInterceptor bean definition, which contains the
            access security metadata definitions:</para>

            <informalexample>
              <para><programlisting>&lt;bean id="filterSecurityInterceptor" class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&gt;
        &lt;property name="authenticationManager" ref="authenticationManager"/&gt;
        &lt;property name="accessDecisionManager" ref="httpRequestAccessDecisionManager"/&gt;
        &lt;property name="securityMetadataSource"&gt;
            &lt;sec:filter-invocation-definition-source&gt;
                &lt;sec:intercept-url pattern="/generateInvoice.do" access="ROLE_ADMINISTRATOR"/&gt;
                &lt;sec:intercept-url pattern="/**" access="ROLE_EMPLOYEE"/&gt;
            &lt;/sec:filter-invocation-definition-source&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</programlisting>As you can see, anyone who is an employee
              can access any section of the site, but only administrators
              (i.e. the 'admin') user can generate invoices.</para>

              <para>A similar provision is made for payments. Application
              classes will be scanned for security annotations, as requested
              by the following bean definition:</para>

              <programlisting>
    &lt;sec:global-method-security secured-annotations="enabled"/&gt;
</programlisting>
            </informalexample>
          </informalexample></para>
      </section>

      <section>
        <title>Configuring Spring beans through JMX</title>

        <para>JMX is a very important tool for monitoring and configuring Java
        applications. Collecting information about the system and the ability
        of making configuration at runtime are important administration
        features. For this example, the requirement is to be able to turn
        auditing on and off, at runtime, whenever required. Removing an aspect
        once it has been applied by Spring is not possible, so the solution in
        this case is to define a flag property on the aspect, which controls
        whether the auditing functionality will be invoked or not.</para>

        <para>In order to be able to make changes at runtime, the Spring bean
        which implements the aspect will be configured as a JMX bean and
        registered in the MBean server of JBoss. In this example, we are using
        annotations to define Spring-specific JMX metadata. The complete
        definition for the PaymentAuditor is:</para>

        <para><informalexample>
            <para><programlisting>@ManagedResource(objectName = "sportsclub:name=paymentAuditor", description = "Payment Auditor")
@Component
public class PaymentAuditor
{

   private static final Log LOG = LogFactory.getLog(PaymentAuditor.class);

   private boolean enabled = true;

   @ManagedAttribute(description = "Audit enabled")
   public void setEnabled(boolean enabled)
   {
      LOG.info("Audit " +  (enabled ? "enabled":"disabled"));
      this.enabled = enabled;
   }

   @ManagedAttribute(description = "Audit enabled")
   public boolean getEnabled()
   {
      return this.enabled;
   }

   public void auditPayment(Long accountId, BigDecimal amount)
   {
      if (this.enabled)
      {
         LOG.info("A payment has been made to account " + accountId + " for the amount of " + amount);
      }
   }
}</programlisting>The annotations ManagedResource and ManagedAttribute are
            using to indicate what classes and properties are JMX-managed. In
            order to expose the bean through JMX, it must be exported using
            Spring's MBean Exporter.</para>

            <para><programlisting>&lt;bean id="attributeSource" class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;

   &lt;bean class="org.springframework.jmx.export.MBeanExporter"&gt;
       &lt;property name="autodetectModeName" value="AUTODETECT_ASSEMBLER"/&gt;
       &lt;property name="ensureUniqueRuntimeObjectNames" value="true"/&gt;
       &lt;property name="namingStrategy"&gt;
           &lt;bean class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
               &lt;property name="attributeSource" ref="attributeSource"/&gt;
           &lt;/bean&gt;
       &lt;/property&gt;
       &lt;property name="assembler"&gt;
           &lt;bean class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
               &lt;property name="attributeSource" ref="attributeSource"/&gt;
           &lt;/bean&gt;
       &lt;/property&gt;
   &lt;/bean&gt;</programlisting></para>
          </informalexample></para>

        <para>As a result, you can turn this functionality on and off directly
        from the JBoss AS JMX administration console, using the
        "sportsclub:name=paymentAuditor" bean to interact with the payment
        auditor.</para>

        <para>As explained in the JMS section, a separate MBean is set up for
        setting messages to the payment notifications message queue.</para>
      </section>

      <section>
        <title>Payment processing: exposing a web service</title>

        <para>Another way of interacting with external applications, is by
        exposing a web service. In this scenario, payment notifications may
        not arrive only as asynchronous events on a message queue, but also as
        synchronous web service invocations. For this purpose, the application
        will implement two web services using two different
        technologies:</para>

        <itemizedlist>
          <listitem>
            <para>a Spring-injected JAX-WS-based web service
            (contract-first);</para>
          </listitem>

          <listitem>
            <para>a complete Spring Web Services-based implementation
            (contract-last);</para>
          </listitem>
        </itemizedlist>

        <section>
          <title>Using a JAX-WS web service</title>

          <para>In this scenario, a JAX-WS annotated class is provided by the
          application:</para>

          <informalexample>
            <para><programlisting>@WebService
public class PaymentNotificationService extends SpringBeanAutowiringSupport
{

   @Autowired
   private PaymentProcessor paymentProcessor;

   @WebMethod
   public Long notifyPayment(Long accountNumber, BigDecimal amount)
   {
      return paymentProcessor.processPayment(accountNumber, amount);
   }

}</programlisting>By extending SpringBeanAutowiringSupport, the class
            PaymentNotificationService will be injected automatically with the
            same PaymentProcessor instance that is used by the JMS
            notification processor, and defined in the application context
            created from WEB-INF/spring-business-context.xml. This is
            necessary, because no bean of the type PaymentNotificationService
            is defined in the application context. Instead, the web service is
            defined and mapped as a servlet in /WEB-INF/web.xml:</para>

            <para><programlisting>&lt;servlet&gt;
       &lt;servlet-name&gt;PaymentNotificationService&lt;/servlet-name&gt;
       &lt;servlet-class&gt;org.jboss.snowdrop.samples.sportsclub.ws.PaymentNotificationService&lt;/servlet-class&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
       &lt;servlet-name&gt;PaymentNotificationService&lt;/servlet-name&gt;
       &lt;url-pattern&gt;/ws/payment&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;</programlisting>As a result, the a JAX-WS web
            service can be accessed at http://localhost:8080/ws/payment. The
            service can be tested using a free SOAP testing tool such as SOAP
            UI.</para>
          </informalexample>
        </section>

        <section>
          <title>Implementing a Spring Web Services web service</title>

          <para>Spring Web Services is focused on implementing contract-first
          web services, as opposed to the contract-last approach taken in the
          JAX-WS example (although it should be noted that JAX-WS can support
          contract-last web services too). In the contract-first development
          style, the WSDL and request/reply document schemas are produced
          first, and define the contract between the service client and
          implementor. It is the responsibility of the service supplier to
          handle the request and reply documents appropriately.</para>

          <para></para>

          <para>The structure of the Spring-WS based web service is similar to
          a Spring MVC application. The entry point is a distinct type of
          dispatcher servlet, backed by an application context definition, as
          follows (Spring 3-based applications may omit the VFS-ready
          application context declaration):</para>

          <informalexample>
            <para><programlisting>&lt;servlet&gt;
  &lt;servlet-name&gt;spring-ws-servlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.springframework.ws.transport.http.MessageDispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextClass&lt;/param-name&gt;
      &lt;param-value&gt;org.jboss.spring.vfs.context.VFSXmlWebApplicationContext&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
         &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
         &lt;param-value&gt;/WEB-INF/spring-ws-config.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
   &lt;servlet-name&gt;spring-ws-servlet&lt;/servlet-name&gt;
   &lt;url-pattern&gt;/spring-ws/payment&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</programlisting></para>
          </informalexample>

          <para>The actual endpoint that handles the SOAP requests is defined
          as follows:</para>

          <informalexample>
            <para><programlisting>@Endpoint
public class PaymentNotificationHandler
{
   @Autowired
   private PaymentProcessor paymentProcessor;

   @PayloadRoot(localPart = "notifyPayment", namespace = "http://ws.sportsclub.samples.snowdrop.jboss.org/")
   public PaymentResponse notifyPayment(PaymentRequest paymentNotification)
   {
      Long paymentId = paymentProcessor.processPayment(paymentNotification.getAccountNumber(), paymentNotification.getAmount());
      return new PaymentResponse(paymentId);
   }

}</programlisting></para>

            <para>The @Endpoint annotation indicatest that this class contains
            web service endpoint methods and allows for this component to be
            detected as a Spring bean through classpath scanning. The
            @PayloadRoot anotation indicates that any SOAP request submitted
            to the dispatcher servlet will be routed to the notifyPayment
            method if the root element of the payload is<code>
            {http://ws.sportsclub.samples.snowdrop.jboss.org/}notifyPayment</code>.
            The request payload will be automatically unmarshalled in a
            PaymentRequest object sent as argument to the method. The return
            value is a PaymentResponse object which will be automatically
            marshalled as XML content and will become the payload of the SOAP
            response that gets sent back. IThe Spring Web Services
            configuration indicates that a JAXB marshaller should be used
            specifically in this case.</para>

            <informalexample>
              <para><programlisting>&lt;bean id="marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller"&gt;
        &lt;property name="classesToBeBound"&gt;
            &lt;list&gt;
                &lt;value&gt;org.jboss.snowdrop.samples.sportsclub.ws.PaymentRequest&lt;/value&gt;
                &lt;value&gt;org.jboss.snowdrop.samples.sportsclub.ws.PaymentResponse&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</programlisting></para>
            </informalexample>

            <para>The detailed application context definition can be found in
            the src/webapp/WEB-INF/spring-ws-config.xml file of the context
            configuration. The web service can be accessed at</para>
          </informalexample>
        </section>
      </section>
    </section>
  </chapter>
</book>
