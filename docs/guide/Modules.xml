<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE bookinfo PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "guide.ent">
%BOOK_ENTITIES;
]>

<chapter>
    <title>Using JBoss and Spring Together</title>

    <para>This chapter will describe the various Spring and JBoss integration
    use cases covered by the application and how are they implemented in
    Ticket Monster.</para>

    <section>
      <title>Integration of JBoss and Spring Use Cases</title>

      <para>The Ticket Monster application covers a number of JBoss and Spring
      integration use cases. The scenarios selected for this example are
      focusing on using the Java EE 6 services provided by the JBoss
      Application Server in Spring applications. Below, the various use cases
      are grouped into categories:</para>

      <table>
        <title>Overview of Spring/JBoss Integration Use Cases</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Category</entry>

              <entry align="center">Use case</entry>

              <entry align="center">How does this involve JBoss AS</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Persistence</entry>

              <entry>Spring/JPA integration</entry>

              <entry>The Persistence Unit is deployed by JBoss and retrieved
              from JNDI to be injected into Spring beans. PersistenceContext
              is shared with surrounding EJBs (if any).</entry>
            </row>

            <row>
              <entry>Testing</entry>

              <entry>Unit-testing components that have managed infrastructure
              dependencies</entry>

              <entry>The DataSource and EntityManager are managed by JBoss and
              acquired from JNDI by Spring when the application is running. In
              the case of JBoss, developers can test their code in isolation
              using Spring-specific replacements that 'simulate' the JBoss
              environment.</entry>
            </row>

            <row>
              <entry>Business Logic</entry>

              <entry>Spring-based service beans</entry>

              <entry>The business services are Spring-managed and wrapped into
              transactions managed by Spring's interceptors. The
              TransactionManager in use is the JTATransactionManager using
              JBoss Transactions provided in JBoss AS.</entry>
            </row>

            <row>
              <entry>User Interface</entry>

              <entry>Spring MVC, JSON, and jQuery UI</entry>

              <entry>The application uses Spring MVC to create the web
              controllers, as well as using JSON services to update
              information displayed in the web view. jQuery UI, specifically
              Accordion, is used for some particular displays.</entry>
            </row>

            <row>
              <entry>Aspect-Oriented Programming</entry>

              <entry>Spring-based weaving of POJO aspects</entry>

              <entry>This use case does not have any JBoss AS-specific
              functionality.</entry>
            </row>

            <row>
              <entry>Security</entry>

              <entry>Application-server pre-authentication</entry>

              <entry>The application uses Spring Security for authorizing
              access to resources. Authentication is provided by the
              application server.</entry>
            </row>

            <row>
              <entry>Caching</entry>

              <entry>Spring-based management of cache</entry>

              <entry>The application uses the Spring SimpleCacheManager to
              retrieve a ConcurrentMapCache, which tracks seat allocations,
              for future reservations. This CacheManager can be obtained using
              either a bean definition or Infinispan.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Domain Model</title>

      <para>This section includes a description of the entities used by Ticket
      Monster, specifically focusing on how they are interconnected,
      illustrated by flow charts. It will not go into great depth describing
      each individual field, as many of these fields are primitives whose
      purpose can be ascertained from a quick analysis of the class definition
      or use. As well, this section will provide a brief overview of the
      session-scoped BookingState object.</para>

      <section>
        <title>Entities</title>

        <para>The package org.jboss.spring.ticketmonster.domain does not
        include any classes which interact directly with Spring. However, the
        domain package is important as it contains definitions for the
        application's entities. The entities of the Ticket Monster application
        can be divided into three categories: show entities, allocation
        entities, and document entities. Below are three entity diagrams,
        showing the entities of each group and how they are connected. Note
        that arrows lead from one entity to a field of that entity, i.e. there
        is an arrow pointing from the VenueLayout entity to the Venue entity
        becuase VenueLayout has a Venue field in its definition. Further, the
        numbers beside each arrow connecting entities indicates the
        multiplicity of the connection. For example, the connection between
        VenueLayout and Venue is (1..n):1 as there can be many different
        VenueLayout objects for the same Venue. On the other hand, Show and
        VenueLayout have a 1:1 connection as there can only be one distinct
        VenueLayout for a given Show object.</para>

        <para>For administrator use cases, show entities are of utmost
        importance. As the name would suggest, these entities revolve around
        Show objects, i.e. instances of a given Event at a specific Venue on a
        certain Date. A Show object has a field for the Event it is an
        instance of, the Venue it is being held at, the date, and the layout
        of the venue for that Show (a VenueLayout object). The entity diagram
        for Ticket Monster's show-related entities is given below:</para>

        <figure>
          <title>Ticket Monster Show Entity Diagram</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="Images/ShowEntities.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The allocation entities are more aligned with Ticket Monster's
        user use cases. These entities deal with seats that have been
        purchased by users (Allocation objects) and how those seats fit into
        the purchases for a given Show. An Allocation object is created when a
        User purchases seats that they have previously reserved. This
        Allocation object holds the following information: the User who made
        it, the Show it belongs to, the SectionRow where the purchased seats
        are located, the quantity, the first seat, and the last seat. From the
        Allocation's SectionRow field, we can retrieve the Section that the
        seat is in, and, through that, the price and the VenueLayout. Thus,
        from a User's Allocation objects we can determine what Shows they have
        purchased tickets to, where their seats are at each Show, and the
        total price of their purchase.</para>

        <figure>
          <title>Ticket Monster Allocation Entity Diagram</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="Images/AllocationEntities.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>To provide descriptions for Event and Venue objects, Ticket
        Monster stores these Strings in a distinct entity called a Document. A
        Document object's content is the Revision field which holds the
        current content of the Document. Thus, to change the description of an
        Event or Venue, one can simply create a new Revision object with the
        desired description and set this as the active field for the Event or
        Venue's description (a Document object). This simple entity
        relationship is shown in the diagram below. Note that the relationship
        between Document and Revision is described as one-to-many in this
        diagram. In the Document class definition, this relationship is
        annotated as @OneToOne; however, this annotation is simply used for
        the purpose of matching the Document to the active Revision. The
        logical relationship is still one-to-many, as there can be many
        Revisions which map to the same Document object.</para>

        <figure>
          <title>Ticket Monster Document Entity Diagram</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="Images/DocumentEntities.png" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>BookingState and Session-Scoped Objects</title>

        <para>For this application's use cases, we require that Users are able
        to update reservations made during the current session (provided that
        the reservation has not been finalized yet) as well as make
        reservations for many different shows while still maintaining a record
        of all allocations made and the total price of said allocations. To
        accomplish this, we create a BookingState class in Ticket Monster's
        domain package and declare a session-scoped BookingState bean. In
        other words, a BookingState object will be created whenever a User
        logs in to the application, and that BookingState object will be
        associated with that User. As well, we use the Spring AOP namespace
        and mark the bean as &lt;aop:scoped-proxy&gt;, meaning that we can
        inject this object in multiple locations in the business logic and be
        confident that the same instance will be included in each case. The
        bean definition for the BookingState object, located in
        src/main/resources/META-INF/spring/bookingState.xml, is provided
        below:<informalexample>
            <programlisting>&lt;bean id="bookingState" class="org.jboss.spring.ticketmonster.domain.BookingState" scope="session"&gt;
    &lt;!-- This next element affects the proxying of the surrounding bean. --&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;</programlisting>
          </informalexample></para>

        <para>This BookingState object is then used to maintain a list of the
        reservations and Allocations made by the User in the current session,
        adding a reservation to the list of reserved seat blocks when it is
        made, and creating and adding a new Allocation object to the list of
        Allocations when it is finalized. With this list of the User's
        reserved seat blocks, when a new reservation is made, we check if a
        reservation with the same key (show ID and row ID pair) that can be
        updated. Otherwise, we create a new reservation. This BookingState
        object can then be used to calculate total price and display the
        purchased seats when a User logs out.</para>

        <para>A final important note about the BookingState class is that we
        must return it to its original state before it is destroyed. For
        example, we would not want reservations that were made, but not
        finalized, to stay in the cache after the User logged out. To do this,
        we use the @PreDestroy annotation. Using @PreDestroy to annotate a
        method, cleanup(), which reverses reservations that were not finalized
        and clears many of the BookingState object's fields, we ensure that
        this method is called before the BookingState bean is garbage
        collected. </para>
      </section>
    </section>

    <section>
      <title>Persistence Implementation - JPA</title>

      <para>The application's persistence strategy is implemented using the
      Java Persistence API (JPA). Persistence-related classes are defined in
      the org.jboss.spring.ticketmonster.repo package. This package includes
      implementations of repository interfaces for database access, and Spring
      context definition fragments that can be re-used elsewhere in the
      application. This section describes how JPA was used to implement
      persistence in the Ticket Monster example, as well as how the various
      repository implementations can be unit tested with the JPA
      implementation.</para>

      <section>
        <title>JPA Implementation</title>

        <para>JPA provides a parametrized superclass that is Spring-agnostic
        as well (except for the usage of the Spring @Autowired annotation -
        which can be replaced by a simple setter if any reference to Spring
        needs to be removed). For database access, the JPA implementation uses
        the JPA EntityManager (javax.persistence.EntityManager) interface to
        query the database and retrieve results. The JPA Persistence Unit (and
        subsequent EntityManager) are created by the JBoss Application Server,
        not by Spring (though the EntityManager is injected by Spring, it is
        acquired from JNDI). The Spring application context configuration
        fragments can be found in the following locations:</para>

        <itemizedlist>
          <listitem>
            <para>src/main/resources/META-INF/spring/ticketmonster-business-context.xml
            - contains Spring bean definitions for repository of
            implementations, assumes that the EntityManager bean definition is
            contained in the infrastructure.xml file</para>
          </listitem>

          <listitem>
            <para>src/main/resources/META-INF/spring/infrastructure.xml -
            contains definitions for infrastructure-related Spring beans, such
            as the data source, EntityManager, and JTA transaction
            manager</para>
          </listitem>

          <listitem>
            <para>src/main/resources/META-INF/persistence.xml - contains the
            persistence unit definition for ticketmonsterPU</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>JUnit Testing of the Repositories</title>

        <para>With the infrastructure of the application coupled so tightly to
        the application server, we are presented with the issue of thoroughly
        unit testing and debugging the repositories in isolation, before they
        are fully integrated with the rest of the application.</para>

        <para>If at deployment, we use services provided by the JBoss
        Application Server, such as the data source, EntityManager, and
        transaction manager, then for the unit tests, we will use an embedded
        data source, Spring's ability to create a LocalEntityManager, and its
        local transaction manager capabilities.</para>

        <para>For this, we use the spring-test-infrastructure module, a
        test-scoped dependency in the project's pom. This module contains the
        modules used for setting up an embedded database (producing a
        DataSource that can be injected into the
        LocalContainerEntityManagerFactoryBean). The localized EntityManager
        and transaction manager definitions is located in the
        src/test/resources/test-context.xml file, while other definitions
        related to the JUnit test context can be found in the
        src/test/resources/META-INF directory.</para>

        <para>The JUnit tests are located in the
        org.jboss.spring.ticketmonster.test package of the src/test/java
        directory. The unit tests will use the test context and local
        infrastructure XML files as in the following example:<informalexample>
            <programlisting>@ContextConfiguration(locations = {"classpath:test-context.xml",
"classpath:/META-INF/spring/ticketmonster-business-context.xml",
"classpath:/META-INF/test-bookingState.xml"})
@RunWith(SpringJUnit4ClassRunner.class)
@Transactional
@TransactionConfiguration(defaultRollback=true)
public class TestTicketMonsterRepository() {
/* JUnit tests */
}</programlisting>

            <para>This configuration reuses the 'application-specific' context
            configuration fragment, i.e. the repository bean definitions, as
            well as two test-specific (or otherwise said local) context
            configuration fragments in order to create a Spring context in
            isolation. Thus, the functionality provided by the repositories
            can be tested outside the running application.</para>
          </informalexample></para>
      </section>
    </section>

    <section>
      <title>Service Layer</title>

      <para>On top of the domain and persistence layer sits the service layer
      of the application. Its role is to co-ordinate the domain objects and
      repositories in order to perform higher level operations. This is also
      the layer which provides transaction demarcation, using Spring's
      @Transactional annotation. One consideration for which transaction
      demarcation should be done at service level is to ensure that the
      changes made by service operations are atomic. Otherwise, concurrent
      operations may leave the application data in an inconsistent state.
      Demarcating transactions at the repository/DAO level should be done
      carefully, taking into consideration that multiple repository/DAO
      invocations that are not surrounded by a wrapping transactions will
      execute in separate transactional contexts.</para>

      <para>In the Ticket Monster application, the service layer consists of
      the ReservationManager and AllocationManager interfaces. These
      interfaces are implemented using Spring; both the interfaces themselves
      and the classes implementing them can be found in the
      org.jboss.spring.ticketmonster.service package.</para>

      <para>This Spring-based service layer exposes a number of service beans
      that can be consumed by the UI, which are injected with the beans
      defined in the persistence layer, in
      src/main/ticketmonster-business-context.xml, much like the repositories.
      Given how this is a fairly straightforward Spring configuration, we will
      not insist much on this topic, except for outlining that this is the
      level where transaction demarcation is provided by the use of the
      appropriate Spring annotations. Spring Security is also used to ensure
      that only users with the appropriate authorization can make changes to
      the cache and database. For example, users who are just browsing Ticket
      Monster for event information should not be able to reserve seats, thus
      allocating them in the cache, unless they have logged in to an account
      with Ticket Monster.</para>
    </section>

    <section>
      <title>Presentation Layer</title>

      <para>The Ticket Monster web application illustrates how we can
      integrate Spring and Java EE technologies in the presentation layer, in
      this case using Spring MVC to create the web controllers and JSF to
      handle display of the various pages:</para>

      <section>
        <title>Configuration of Spring MVC and Apache Tiles</title>

        <para>To integrate the UI and Spring MVC, we use the Spring provided
        DispatcherServlet, defined in src/main/webapp/WEB-INF/web.xml as shown
        in the snippet of code below:<informalexample>
            <programlisting>&lt;servlet&gt;
    &lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/spring-webflow-config.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;


&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Spring MVC Dispatcher Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/flow/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</programlisting>
          </informalexample></para>

        <para>The Spring business application is bootstrapped by the
        ContextLoaderListener, a Spring web class, defined in
        /WEB-INF/web.xml. The Spring configuration file in use is
        /WEB-INF/ticketmonster-mvc-context.xml, which defines a number of
        Spring beans that are used directly in the web tier by the JSP pages.
        These beans include a ResourceBundleMessageSource, so that messaging
        macros can be used in JSP, and a ContentNegotiatingViewResolver.
        Further, web.xml includes several bean definitions required in order
        to properly configure Apache Tiles; these include a TilesViewResolver
        to map view names to Tiles Definitions and a TilesConfigurer to
        initialize the Tiles CompositeView system. The bean definitions are
        included below:<informalexample>
            <programlisting>&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.tiles2.TilesViewResolver"&gt;
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.tiles2.TilesView"/&gt;
    &lt;property name="order" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles2.TilesConfigurer"&gt;
    &lt;property name="definitions"&gt;
        &lt;list&gt;
            &lt;value&gt;/WEB-INF/**/layouts.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/**/views.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>Spring MVC</title>

        <para>Ticket Monster provides an example of how Spring can be
        integrated with the JBoss Application Server, using Spring for the web
        tier and presentation layer of the application. This is accomplished
        by using the Spring Web MVC framework. Spring MVC allows us to easily
        use annotations to denote controllers, map controllers to various
        views, create GET and POST methods, to name just a few functions of
        Spring MVC. The Spring MVC beans are defined in the
        /WEB-INF/ticketmonster-mvc-context.xml file, referenced by the
        DispatcherServlet referenced in the previous section. First, we must
        add some XML elements to ticketmonster-mvc-context.xml in order to
        take full advantage of Spring MVC, as shown below:<informalexample>
            <programlisting>&lt;context:component-scan base-package="org.jboss.spring.ticketmonster.mvc"/&gt;

&lt;mvc:annotation-driven /&gt;

&lt;mvc:resources mapping="/static/**" location="/" /&gt;

&lt;mvc:default-servlet-handler/&gt;</programlisting>
          </informalexample></para>

        <para>The above elements are necessary for the following
        reasons:<itemizedlist>
            <listitem>
              <para>&lt;mvc:annotation-driven /&gt; advises that the
              application to search for Spring MVC annotations to indicate
              controllers, request mappings, etc.</para>
            </listitem>

            <listitem>
              <para>&lt;context:component-scan
              base-package="org.jboss.spring.ticketmonster.mvc"/&gt; indicates
              where to scan for Spring MVC annotations (in this case the
              org.jboss.spring.ticketmonster.mvc package)</para>
            </listitem>

            <listitem>
              <para>&lt;mvc:resources mapping="/static/**" location="/" /&gt;
              maps static resources, such as CSS files, images, etc. to the
              fake URL '/static/**', so that the servlet is mapped to
              '/'</para>
            </listitem>

            <listitem>
              <para>&lt;mvc:default-servlet-handler/&gt; allows the
              DispatcherServlet to be mapped to '/', overriding the
              container's default servlet</para>
            </listitem>
          </itemizedlist></para>

        <para>The Ticket Monster application uses Spring 3 MVC
        annotation-based configuration, exemplified below via a skeleton
        version of the BookingFormController:</para>

        <informalexample>
          <programlisting>@Controller
@RequestMapping("/bookings")
public class BookingFormController {

/* Injection of repositories and service managers */

    @RequestMapping(value = "/{id}", method=RequestMethod.GET)
    public String viewShow(@PathVariable("id") Long id, Model model) {}

    @RequestMapping(value="/checkout", method=RequestMethod.POST)
    public String onSubmit(Model model) {}

    @RequestMapping(value = "/allocate", method=RequestMethod.GET, produces = "application/json")
    public @ResponseBody boolean updateAllocation(Long showId, Long priceCategoryId, int quantity) {}
}</programlisting>
        </informalexample>

        <para>The above skeleton of code demonstrates the use of some very
        important annotations when using Spring MVC to handle the web tier of
        an application. These annotations include:<itemizedlist>
            <listitem>
              <para>@Controller - designates the annotated class as a Spring
              MVC controller</para>
            </listitem>

            <listitem>
              <para>@RequestMapping - maps the specific class and/or function
              to a URL, relative to the servlet path</para>
            </listitem>

            <listitem>
              <para>RequestMethod - though not an annotation per se, it is
              still important as it designates the specific method as a GET,
              POST, etc.</para>
            </listitem>

            <listitem>
              <para>@PathVariable - binds an element from a specified URL path
              to a variable, e.g. bookings/{id} binds the value of id to a
              variable for a GET method</para>
            </listitem>
          </itemizedlist></para>

        <para>Note that, although not used in this example, method parameters
        can also be specified via the URL using the @RequestParameter
        annotation. For example, in the EventController class, the getEvents()
        method first checks if any parameters were specified regarding which
        events to retrieve. In that example, the user can specify parameters
        such as 'major' by navigating to URL like '/events?major=true' and the
        getEvents() method would retrieve all events that were marked as
        major.</para>
      </section>

      <section>
        <title>JavaScript Object Notation</title>

        <para>JavaScript Object Notation (JSON) is a subset of the JavaScript
        language used to represent simple objects like associative arrays and
        basic data structures. In Ticket Monster, JSON services are mapped to
        the URLs listed below for the described purposes (the JSP file with
        the JSON service definition is listed in parentheses):<itemizedlist>
            <listitem>
              <para>/shows?eventId={eventId}&amp;venueId={venueId} - retrieves
              the show times for a given event and venue pair, as specified by
              the event and venue IDs in the URL (eventDetails.jsp)</para>
            </listitem>

            <listitem>
              <para>/venues/{venueId} - retrieves all relevant information
              about the venue specified by the given ID, such as the venue
              address and description</para>
            </listitem>

            <listitem>
              <para>/categories?eventId={eventId}&amp;venueId={venueId} -
              retrieves information on all seating sections for shows with the
              given event and venue IDs (as different events at the same venue
              may have different seating layout) such as section names,
              available price categories along with their prices
              (eventDetails.jsp)</para>
            </listitem>

            <listitem>
              <para>/bookings/allocate?showId={showId}&amp;priceCategoryId={priceCategoryId}&amp;quantity={quantity}
              - searches the cache of seat blocks, both reserved and
              purchased, for an allocation in the price category specified by
              priceCategoryId for the show specified by showId. Before
              searching for a reservation, the JSON service first checks if
              there are any other seating requests by that User within that
              section, in which case it combines the requests from the various
              categories into one large request for that section. Finally,
              this method searches for an existing reservation, trying to
              update it if it exists and creating a new reservation if it does
              not (showDetails.jsp)</para>
            </listitem>
          </itemizedlist></para>

        <para>JSON services are implemented by creating a JavaScript function,
        and passing the parameters of the service to the JavaScript function.
        Then, we create a String variable with the targeted URL of the JSON
        service to get the results of the method call, as shown in this
        example from showDetails.jsp:<informalexample>
            <programlisting>function updateReservation(showId, priceCategoryId, quantity) {
    baseUrl = '&lt;c:url value="/bookings/allocate?"/&gt;';
    jQuery.getJSON(baseUrl + "showId=" + showId + "&amp;priceCategoryId=" + priceCategoryId + "&amp;quantity=" + quantity, function (result) {
        if(result == true)
            $("div#priceCategory_" + priceCategoryId).text("Available seats have been allocated.");
        else
            $("div#priceCategory_" + priceCategoryId).text("Insufficient available seats.");
    });
}</programlisting>
          </informalexample></para>

        <para>However, to properly bind the URL used in the jQuery.getJSON()
        call to a Java method, we must use some simple Spring Web annotations.
        In the @RequestMapping annotation, we must add 'produces =
        "application/json" ' to indicate that there will be a JSON service
        corresponding to the URL specified in the same annotation. As well, we
        must annotate the return type of the Java method with the
        @ResponseBody annotation so that Spring will serialize to JSON. The
        updateAllocation() method, from the BookingFormController class, is
        provided as an example of how these annotations should be used
        properly:<informalexample>
            <programlisting>@RequestMapping(value = "/allocate", method=RequestMethod.GET, produces = "application/json")
public @ResponseBody boolean updateAllocation(Long showId, Long priceCategoryId, int quantity) {
    boolean success = false;
    int sectionQuantity = 0;

    Long sectionId = showDao.findPriceCategory(priceCategoryId).getSection().getId();
    int previousQuantity = reservationManager.getBookingState().updateCategoryRequests(priceCategoryId, quantity);

    for(PriceCategoryRequest categoryRequest : reservationManager.getBookingState().getCategoryRequests()) {
        if(categoryRequest.getPriceCategory().getSection().getId().equals(sectionId)) {
            sectionQuantity += categoryRequest.getQuantity();
        }
    }

    success = reservationManager.updateSeatReservation(showId, sectionId, sectionQuantity);

    if(success == false) {
        reservationManager.getBookingState().updateCategoryRequests(priceCategoryId, previousQuantity);
    }

    return success;
}</programlisting>
          </informalexample></para>
      </section>

      <section>
        <title>jQuery UI</title>

        <para>An important feature of Ticket Monster is the ability for a user
        to view all the seating sections available at a specific venue, as
        well as the various price categories available in each section. To do
        this, Ticket Monster uses the Accordion feature of jQuery UI.
        Accordion is a standard jQuery widget which, given menu of options,
        displays each option of the menu as its own separate header. Each
        header is also its own dropdown, so that, on click, each menu option's
        content will be displayed as a dropdown. One important feature of
        jQuery Accordion is that only one dropdown can be active at a time;
        thus, clicking a different header will cause the currently displayed
        content to collapse.</para>

        <para>In Ticket Monster, jQuery Accordion is implemented on each
        individual event's view page, i.e. /events/{id} where {id} represents
        the selected event's ID. To implement jQuery Accordion, jQuery UI must
        be included in the src/main/webapp directory of the project, as
        jquery-ui-1.8.14.custom.min.js is in Ticket Monster. Once this is
        included, Accordion only requires some simple HTML, as demonstrated in
        the example below, taken from the jQuery UI website:<informalexample>
            <programlisting>&lt;div id="accordion&gt;
    &lt;h3&gt;&lt;a href="#"&gt;First Header&lt;/a&gt;&lt;/h3&gt;
    &lt;div&gt;First menu option content&lt;/div&gt;
    &lt;h3&gt;&lt;a href="#"&gt;Second Header&lt;/a&gt;&lt;/h3&gt;
    &lt;div&gt;Second menu option content&lt;/div&gt;
&lt;/div&gt;</programlisting>
          </informalexample></para>

        <para>In Ticket Monster, the Accordion section, located in
        eventDetails.jsp, is implemented using a JavaScript, as a JSON service
        is required to populate the Accordion based on the items selected in a
        dropdown menu. JSON services are very important to Ticket Monster for
        a variety of purposes, such as retrieving a show's price categories as
        well as updating or creating seat reservations.</para>
      </section>
    </section>

    <section>
      <title>Enterprise Integration Features</title>

      <para>The Ticket Monster application provides a few other examples of
      integrating Spring and JBoss. Since all the features are Spring-based,
      they have been included as business services of the web application. All
      the definitions for the following examples can be found in the
      src/main/resources/META-INF/spring directory.</para>

      <section>
        <title>Caching</title>

        <para>An important feature of Ticket Monster is the ability for
        multiple users to reserve tickets for the same show at the same time.
        To provide this functionality, the application must keep track of all
        seat blocks that have been reserved and purchased for a given show at
        all times. However, it would be impractical to persist all of this
        data to the Ticket Monster database. Instead, we take advantage of
        another useful feature provided in Spring 3.1, the Spring Cache
        Abstraction, either by declaring a CacheManager bean or using the
        CacheManager packaged with JBoss AS 7.</para>

        <section>
          <title>CacheManager Configuration</title>

          <para>The Spring Cache Abstraction provides a variety of methods for
          caching, such as annotating entities as @Cacheable and methods as
          @CacheEvict, or dealing directly with a Cache object (often either
          an Ehcache or Concurrent Map Cache) retrieved by a CacheManager. In
          the Ticket Monster example, we will inject a Cache object, declared
          as a bean in /META-INF/spring/ticketmonster-business-context.xml;
          this way, we can retrieve the cache of reservations using this
          CacheManager bean. The CacheManager bean definition, as well as the
          cache configuration, are included below:<informalexample>
              <programlisting>&lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt;
    &lt;property name="caches"&gt;
        &lt;set&gt;
            &lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="reservations"/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
    
&lt;bean id="defaultCache" factory-bean="cacheManager" factory-method="getCache"&gt;
    &lt;qualifier value="reservations"/&gt;
    &lt;constructor-arg value="reservations"/&gt;
&lt;/bean&gt;</programlisting>
            </informalexample></para>

          <para>In the above code, the Cache Manager bean is declared as a
          SimpleCacheManager, which is then injected into the various
          implementations of the service layer interfaces using the @Autowired
          annotation. As well, we also declare a default cache, obtained by
          call calling the getCache() method of the SimpleCacheManager with an
          argument of "reservations", which is a ConcurrentMapCache object. As
          well, the &lt;qualifier&gt; element can be used to identify the
          Cache object when it is injected into our Java classes. This is
          accomplished using the @Qualifier annotation, as demonstrated in the
          simple Cache definition below:<informalexample>
              <programlisting>@Autowired
@Qualifier("reservations")
private Cache reservationsCache;</programlisting>
            </informalexample></para>

          <para>The above definition injects the ConcurrentMapCache bean,
          defined in ticketmonster-business-context.xml, with the qualifier of
          "reservations" into the Java class where this code is placed.</para>
        </section>

        <section>
          <title>Infinispan CacheContainer</title>

          <para>JBoss Application Server 7 provides a simple Infinispan
          subsystem in the server configuration. This Infinispan subsystem can
          be used to define and configure multiple cache container elements.
          Using cache containers provided by the application server, we can
          define several caches for each cache container, and access these
          caches by retrieving a CacheManager object from the application
          server's ResourceManager. The Ticket Monster application properly
          illustrates this functionality. To set it up in one's own
          application, first we must add CacheContainer and Cache definitions
          to the server configuration file, in this case
          ${JBOSS_AS_7_HOME}/standalone/configuration/standalone.xml, as
          illustrated below:<informalexample>
              <programlisting>&lt;cache-container name="ticket-monster" default-cache="reservations"&gt;
    &lt;local-cache name="reservations"&gt;
        &lt;eviction strategy="LRU" max-entries="10000"/&gt;
        &lt;expiration max-idle="100000"/&gt;
    &lt;/local-cache&gt;
&lt;/cache-container&gt;</programlisting>
            </informalexample></para>

          <para>The above XML code should be added to the Infinispan subsystem
          of the standalone.xml file. Next, we must add a file, located in
          META-INF/spring/applicationContextCache.xml, to the application
          classpath. This file, added via the contextConfigLocation context
          parameter in WEB-INF/web.xml, provides the application context
          definition for the Infinispan cache. The contents of the
          applicationContextCache.xml file are explained
          below:<informalexample>
              <programlisting>&lt;cache:annotation-driven/&gt;

&lt;beans profile="local"&gt;
    &lt;infinispan:embedded-cache-manager/&gt;
&lt;/beans&gt;

&lt;beans profile="jboss"&gt;
    &lt;infinispan:container-cache-manager cache-container-ref="cacheContainer"/&gt;
    &lt;jee:jndi-lookup jndi-name="java:comp/env/infinispan/cacheContainer" id="cacheContainer" 
        expected-type="org.infinispan.manager.CacheContainer"/&gt;
&lt;/beans&gt;</programlisting>
            </informalexample></para>

          <para>The &lt;cache:annotation-driven/&gt; tag enables the use of
          Spring Cache Abstraction annotations. The two profile definitions
          create two separate profiles which obtain a CacheManager object in
          two different ways from the application server. The 'local' profile
          uses the CacheManager embedded in JBoss AS 7, whereas the 'jboss'
          profile uses a CacheContainer object to retrieve a CacheManager
          (hence the &lt;infinispan:container-cache-manager&gt; tag). First,
          the 'jboss' profile performs a JNDI lookup for the CacheContainer,
          which was defined earlier in standalone.xml, and the application
          server then uses this CacheContainer to get a CacheManager. To
          specify the active profile, we add the following context parameter
          to WEB-INF/web.xml:<informalexample>
              <programlisting>&lt;context-param&gt;
    &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt;
    &lt;param-value&gt;${active.profile}&lt;/param-value&gt;
&lt;/context-param&gt;</programlisting>
            </informalexample></para>
        </section>

        <section>
          <title>Cache Lookups</title>

          <para>In order to use caching effectively, we must create a CacheKey
          class, located in org.jboss.spring.ticketmonster.domain, which can
          be uniquely associated with each object stored on the cache. In
          Ticket Monster, we cache objects using a key consisting of a show ID
          and a row ID. The actual object stored on the cache, a
          RowReservation, consists of a CacheKey object for that
          RowReservation as well as a LinkedList of SeatBlock objects,
          representing already reserved or purchased seats by their start and
          end seat. In order for objects to be stored and retrieved from the
          cache properly, we must first override the hash() and equals()
          methods of the CacheKey class, which can be generated automatically
          by JBoss Developer's Studio, as shown here:<informalexample>
              <programlisting>@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((rowId == null) ? 0 : rowId.hashCode());
    result = prime * result + ((showId == null) ? 0 : showId.hashCode());
    return result;
}

@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;

    CacheKey other = (CacheKey) obj;

    if (rowId == null) {
        if (other.rowId != null)
            return false;
    } else if (!rowId.equals(other.rowId))
        return false;
    if (showId == null) {
        if (other.showId != null)
            return false;
    } else if (!showId.equals(other.showId))
        return false;
    return true;
}</programlisting>
            </informalexample></para>

          <para>For examples of using the injected CacheManager to retrieve a
          cache, as well as manipulating the retrieved cache, code
          implementation can be found in both the SimpleReservationManager and
          SimpleAllocationManager implementations of Ticket Monster's service
          layer interfaces.</para>
        </section>
      </section>

      <section>
        <title>Aspects and Cross-Cutting Concerns</title>

        <para>Given the use cases of the Ticket Monster application, it is
        very important for the application to keep record of transaction order
        (such as which seats were reserved when and by whom) as well as
        confirmation of payment. One method of the application maintaining
        this information is to use advice on cross-cutting concerns. In Ticket
        Monster, we implement this advice using Spring Aspect-Oriented
        Programming (Spring AOP), which provides a simple set of AspectJ
        annotations that can be used to advise on the application's business
        logic. To configure Spring AOP, first we must add the following
        definition to META-INF/spring/ticketmonster-business-context.xml and
        to WEB-INF/ticketmonster-mvc-context.xml, as both application context
        files include the definitions of beans to be advised:<informalexample>
            <para><programlisting>&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</programlisting></para>
          </informalexample></para>

        <para>This simple XML tag, provided by the Spring aop namespace,
        allows us to use AspectJ annotations to create pointcuts, Advice for
        cross-cutting concerns is contained in the
        org.jboss.spring.ticketmonster.advice package. This package contains
        three separate classes, ControllerLog, ServiceLog, and RepositoryLog.
        These classes contain advice for cross-cutting concerns to deal with
        MVC controllers, service implementations, and repository
        implementations respectively. Below is an example of the use of
        AspectJ annotations to declare pointcuts and cross-cutting advice in
        Ticket Monster's RepositoryLog class:<informalexample>
            <programlisting>@Aspect
@Component
public class RepositoryLog {

    protected final Log logger = LogFactory.getLog(getClass()); 

    @Pointcut("execution(* org.jboss.spring.ticketmonster.repo.AllocationDao.populateCache(..))")
    public void cache() {
    }
    
    @Pointcut("execution(* org.jboss.spring.ticketmonster.repo.UserDao.getByName(String)) &amp;&amp; args(username)")
    public void getUser(String username) {
    }
    
    @Before("cache()")
    public void startup() {
        logger.info("Populating the reservations cache with previously made allocations that are stored in the database.");
    }
    
    @AfterThrowing("cache()")
    public void bootstrapFail() {
        logger.info("Population of the cache with allocations in the database failed.");
    }
    
    @AfterReturning("cache()")
    public void bootstrap() {
        logger.info("Successfully populated the cache with Allocation objects from the database.  Already purchased SeatBlocks have been marked as such.");
    }
    
    @AfterReturning("getUser(username)")
    public void user(String username) {
        logger.info("Retrieved User object from the database with a 'username' field of " + username + ".");
    }
}</programlisting>
          </informalexample></para>

        <para>In the above example, the @Aspect annotation indicates to the
        application that the RepositoryLog class should be scanned for
        pointcuts and cross-cutting advice. As well, the @Component annotation
        indicates that this class is a Spring-managed component. We divide the
        advice performed by Ticket Monster across a variety of classes. This
        allows us to create easily readable code, avoiding large amounts of
        code between the pointcut definition and advice on that pointcut, as
        well as add more advice classes easily. By annotating each class with
        @Component, we no longer have to declare each bean separately in
        context files. Instead, we use a Spring component scan to find any
        beans that should be added to the application context. This is
        accomplished by adding the following line to
        META-INF/spring/ticketmonster-business-context.xml:<informalexample>
            <programlisting>&lt;context:component-scan base-package="org.jboss.spring.ticketmonster.advice"/&gt;</programlisting>
          </informalexample>The @Pointcut annotation defines a pointcut, which
        specifies the joinpoint when cross-cutting advice will be applied,
        such as the execution of a particular method or within a certain type,
        to provide two examples. In the case of an execution pointcut, where
        the joinpoint occurs on the execution of a method, we use annotations
        such as @Before, @AfterReturning, @AfterThrowing, or @After, to
        indicate whether the joinpoint will occur before execution, after
        successful execution, after an exception is thrown, etc. Note that, in
        the above example, to pass a parameter to advice via the pointcut, we
        must add the parameter type to the execution designator and an args()
        designator, specifying the parameter names to be passed. As well, it
        should be mentioned that, while in this example, we only use
        cross-cutting advice to log information, aspect-oriented programming
        can be used for more complex uses, e.g. calls to methods upon
        successful completion of each transaction.</para>

        <para>It is very important to note that logging is a simple task that
        does not require Spring AOP, it could easily be done directly in the
        methods themselves. However, Spring AOP is a very powerful tool which
        can be used in a wide variety of very complex use cases. The use of
        Spring AOP in Ticket Monster simply provides an example of how to
        properly configure Spring AOP and how to implement it in simple use
        cases.</para>
      </section>

      <section>
        <title>JBoss-Authenticated Security</title>

        <para>To ensure that only authenticated users are able to make
        reservations and pay for previously reserved seats, we use Spring
        Security 3.1.0.RC2 to restrict access to certain pages of the Ticket
        Monster example. Access to the reservations and checkout page (i.e.
        all URLs of '/booking**') is restricted, as described in
        META-INF/spring/ticketmonster-security-context.xml, To enable Spring
        Security, we must first add this ticketmonster-security-context.xml
        file to the contextConfigLocation, specified as a
        &lt;context-param&gt; elementin web.xml.</para>

        <para>One level of security is added by enabling Spring Security
        annotations. Using these annotations, we can ensure that certain
        methods can only be called by users with the specified credentials.
        This is accomplished by adding the following XML code to the
        ticketmonster-security-context.xml:<informalexample>
            <para><programlisting>&lt;global-method-security pre-post-annotations="enabled"/&gt;</programlisting></para>
          </informalexample></para>

        <para>With these annotations enabled, we can then annotate methods,
        such as the methods of the ReservationManager interface, as
        @PreAuthorize("hasRole('ROLE_USER')"). By including this annotation,
        only those with the role of User, in this case those with an account
        in the Ticket Monster database, can call methods of the
        ReservationManager interface.</para>

        <para>To add another layer of security to the Ticket Monster example,
        we restrict the access to certain URLs within the Ticket Monster
        application. This is accomplished by adding intercept-url definitions
        to the ticketmonster-security-context.xml file:<informalexample>
            <programlisting>&lt;http pattern="/static/**" security="none" /&gt;

&lt;http use-expressions="true"&gt;
    &lt;intercept-url pattern="/bookings/**" access="hasRole('ROLE_USER')"/&gt;
    &lt;intercept-url pattern="/events**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/events/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/venues**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/venues/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/shows/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/categories**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/index.jsp" access="permitAll"/&gt;
    &lt;intercept-url pattern="/**" access="denyAll"/&gt;
    &lt;form-login/&gt;
    &lt;logout logout-success-url="/"/&gt;
&lt;/http&gt;</programlisting>
          </informalexample></para>

        <para>There are a few important points to note from the above section
        of code:<itemizedlist>
            <listitem>
              <para>It is essential to make sure there is no security on the
              '/static/**' URLs, otherwise no images, CSS files, etc. will be
              accessible to non-authenticated users</para>
            </listitem>

            <listitem>
              <para>An &lt;intercept-url&gt; tag should be included to cover
              each web view, even if the access is 'permitAll', though access
              can also be 'denyAll', 'hasRole('ROLE_USER'),
              'hasRole('ROLE_SUPERVISOR'), or custom-defined roles</para>
            </listitem>

            <listitem>
              <para>If JSON services are used, the correct access must be
              given to the URL of the JSON call</para>
            </listitem>

            <listitem>
              <para>The &lt;form-login/&gt; will ensure that Spring Security
              prompts for authentication before displaying a page which the
              user does not currently have authorization to view</para>
            </listitem>
          </itemizedlist></para>

        <para>Finally, we must tell Ticket Monster how to verify a user's
        credentials when they attempt to log in. For security purposes, Ticket
        Monster stores passwords as salted one-way hashes, created by Spring
        Security's StandardPasswordEncoder. Once we have encoded each
        password, we can either store the hashed passwords in the
        ticketmonster-security-context.xml file itself or in the Ticket
        Monster database, querying the database to verify credentials. This
        implementation uses the latter implementation of password encryption,
        as demonstrated by code below from the security context and database
        initialization files.<informalexample>
            <programlisting>// From ticketmonster-security-context.xml

&lt;beans:bean id="encoder" class="org.springframework.security.crypto.password.StandardPasswordEncoder"/&gt;

&lt;authentication-manager&gt;
    &lt;authentication-provider&gt;
    &lt;password-encoder ref="encoder"/&gt;
    &lt;jdbc-user-service data-source-ref="dataSource" 
        users-by-username-query="select username, password, enabled from User where username = ?"
        authorities-by-username-query="select username, 'ROLE_USER' from User where username = ?"/&gt;
    &lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;

// From import.sql

insert into User (id, username, password, enabled, firstName, lastName) values (1, 'sbryzak', '12bfe8fb06f06eedec67fb43ef6ab8c850a577db73e758c40b5fceff86d9e214c36612e430b23a5e', 'true', 'Shane', 'Bryzak');
insert into User (id, username, password, enabled, firstName, lastName) values (2, 'mbg', 'eefcbef8c277b21f88d7fa36dc7e33fbf243587de1cac2dcc4edcaa717796e7326980ad18161bd4f', 'true', 'Marius', 'Bogoevici');
insert into User (id, username, password, enabled, firstName, lastName) values (3, 'rbradley', 'e5b60370d330faeddb4aef7b34ef2877cebcfaad814e62da7e9d3abe8b3be6146410572b2f21047c', 'true', 'Ryan', 'Bradley');</programlisting>
          </informalexample></para>

        <para>For those interested in adding their own User to the database,
        the id, username, firstName, and lastName fields are self-explanatory.
        The enabled field should indicate whether the added user should have
        ROLE_USER priveleges. As well, instructions to encode passwords can be
        found in the Spring Security tutorial at
        http://static.springsource.org/spring-security/site/tutorial.html.</para>
      </section>
    </section>
</chapter>